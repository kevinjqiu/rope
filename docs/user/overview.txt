===============
 Rope Features
===============

.. contents:: Table of Contents


Overview
========

The purpose of this file is to give an overview of some of rope's
features.  It is incomplete.


Keybinding
==========

The keybinding will be customizable in future.  Some of these bindings
are chosen from emacs and some from eclipse.  ('C' stands for Control
key and 'M' for Meta(Alt) key.)

=============  ==========================
key            binding
=============  ==========================
C-x C-p        open/new project
C-x C-n        new file
C-x C-f        find file
C-x b          change active editor
C-x k          close active editor
C-x C-c        exit
M-X p          run active editor
M-X t          run unit-tests
M-Q r          show project tree
F5             refresh project
-------------  --------------------------
C-f            forward character
C-b            backward character
C-n            next line
C-p            previous line
M-f            next word
M-b            previous word
C-v            next page
M-v            previous page
M-l            downcase word
M-c            capitalize word
M-u            upcase word
C-s            start searching
C-q            last edit location
C-x u          undo editing
C-x r          redo editing
C-space        set mark
C-w            cut region
M-w            copy region
C-x C-x        swap mark and insert
C-y            paste
C-x C-s        save
C-x s          save all
C-x U          undo project change
C-x R          redo project change
-------------  --------------------------
M-/            code-assist(auto-complete)
F3             go to definition location
F2             show doc
C-o            show quick outline
C-i            correct line indentation
C-c c          comment current line
C-c C-c        comment region lines
C-G            find occurrences
-------------  --------------------------
M-R            rename refactoring
M-M            extract method
M-V            move refactoring
M-I            inline refactoring
M-C            change method signature
M-L            extract local variable
C-O            organize imports
=============  ==========================


Code Assist(Auto Complete)
==========================

You can complete names as you type by using code assist (``M-/``).
The two capital letters in the left shows the type of the proposal.
In the first column:

* L: ``local``
* G: ``global``
* A: ``attribute``
* T: ``template``
* K: ``keyword``
* B: ``built-in``

In the second column if present:

* C: ``class``
* F: ``function``
* V: ``variable``
* P: ``paramter``
* I: ``imported``

You can use ``main``, ``testcase``, ``hash``, ``eq`` and ``super``
templates.  If you want to add more or edit these you can edit
`rope.ide.codeassist.PythonCodeAssist._get_default_templates` method.


Show PyDoc
----------


Goto Definition
---------------


Refactorings
============

Renaming attributes
-------------------

Consider we have::

  class AClass(object):

      def __init__(self):
          self.an_attr = 1

      def a_method(self, arg):
          print self.an_attr, arg

  a_var = AClass()
  a_var.a_method(a_var.an_attr)

After renaming ``an_attr`` to ``new_attr`` and ``a_method`` to
``new_method`` we'll have::

  class AClass(object):

      def __init__(self):
          self.new_attr = 1

      def new_method(self, arg):
          print self.new_attr, arg

  a_var = AClass()
  a_var.new_method(a_var.new_attr)


Renaming Function Keyword Parameters
------------------------------------

We have::

  def a_func(a_param):
      print a_param

  a_func(a_param=10)
  a_func(10)

After performing rename refactoring on any occurance of ``a_param``
we will have::

  def a_func(new_param):
      print new_param

  a_func(new_param=10)
  a_func(10)


Renaming modules
----------------

Consider the project tree is something like::

  root/
    mod1.py
    mod2.py

``mod1.py`` contains::

  import mod2
  from mod2 import AClass

  mod2.a_func()
  a_var = AClass()

After performing rename refactoring one of the ``mod2`` occurances in
`mod1` we'll get::

  import newmod
  from newmod import AClass

  newmod.a_func()
  a_var = AClass()

and the new project tree would be::
  root/
    mod1.py
    newmod.py


Extract Method
--------------

The position of the mark would be region start and the current
cursor position would be region end. (You can set the mark as in
emacs copy and paste with ``C-space``). ::

  def a_func():
      a = 1
      b = 2 * a
      c = ${region_start}a * 2 + b * 3${region_end}

After performing extract method we'll have::

  def a_func():
      a = 1
      b = 2 * a
      c = new_func(a, b)

  def new_func(a, b):
      return a * 2 + b * 3

For multi-line extractions if we have::

  def a_func():
      a = 1
      ${region_start}b = 2 * a
      c = a * 2 + b * 3${region_end}
      print b, c

After performing extract method we'll have::

  def a_func():
      a = 1
      b, c = new_func(a)
      print b, c

  def new_func(a):
      b = 2 * a
      c = a * 2 + b * 3
      return b, c


Change Method Signature
-----------------------

In the change method signature dialog these shortcuts work:

======  ======================
key     binding
======  ======================
C-n     move downward
C-p     move upward
M-n     move parameter down
M-p     move parameter up
M-r     remove parameter
M-a     add new parameter
======  ======================

The ``value`` field in add new parameter dialog changes all calls
to pass ``value`` as this new parameter if it is non-empty.  You
can do the same thing for existing arguments using inline argument
default value.

Inline argument default value changes all function calls that don't
pass any value as this argument to pass the default value specified
in function definition.

While reordering arguments you should consider the python
language order for argument types (i.e. : normal args, args with
defaults, ``*args``, ``**keywords``).  Rope won't complain if you
don't but python will.


Sorting Imports
---------------

Organize imports now sorts imports, too.  It will sort imports
according to :PEP:`8`::

  [standard imports]

  [third-party imports]

  [project imports]


  [the rest of module]


Handling Long Imports
---------------------

"Handle long imports" command trys to make long imports look better by
transforming ``import pkg1.pkg2.pkg3.pkg4.mod1`` to ``from
pkg1.pkg2.pkg3.pkg4 import mod1``.  Long imports can be identified
either by having lots of dots or being very long.  The default
configuration considers imported modules with more than 2 dots or with
length more than 27 characters to be long.


Basic Type Inference
====================

::

  class AClass(object):

      def __init__(self):
          self.an_attr = 1

      def call_a_func(self):
          return a_func()

  def a_func():
      return AClass()

  a_var = a_func()
  a_var.${codeassist}

  another_var = a_var
  another_var.${codeassist}
  another_var.call_a_func().${codeassist}


Basic support for builtin types::

  a_list = [AClass(), AClass()]
  for x in a_list:
      x.${codeassist}
  a_list.pop().${codeassist}

  a_dict = ['text': AClass()]
  for key, value in a_dict.items():
      key.${codeassist}
      value.${codeassist}


Dynamic Type Inference
======================

Dynamic type inference gets its needed information from running
modules (``M-X p``) or unit tests (``M-X t``).  You open the module
to run (probably your test suite), then use ``M-X p`` or ``M-X t`` if
it is a test suite.  Since as the program runs, rope gathers
type information, the program runs slower.  Right now rope doesn't
have a good interface for running programs.  It just prints the output
to the terminal and does not get inputs.  This will be enhanced in
future releases. After the program is run, you can get better code
assists and some of the refactorings perform much better.

``mod1.py``::

  def f1(param):
      param.${codeassist}
      f2(param).${codeassist}

  def f2(param):
      param.${codeassist}
      return param

Using code assist in specified places does not give any information
and there is actually no information about the return type of `f2` or
the parameter `param` of `f1`.

``mod2.py``::

  import mod1

  class A(object):

      def a_method(self):
          pass

  a_var = A()
  mod1.f1(a_var)

After running `mod2` module using rope's `Run Module`, we get good
code assists in `mod1`.


Builtin Container Types
-----------------------

Builtin types can be handled in a limited way, too::

  class A(object):

      def a_method(self):
          pass

  def f1():
      result = []
      result.append(A())
      return result

  returned = f()
  returned[0].${codeassist}

Test the the proposed completions after running this module.


Guessing Function Returned Value Based On Parameters
----------------------------------------------------

``mod1.py``::

  class C1(object):

      def c1_func(self):
          pass

  class C2(object):

      def c2_func(self):
          pass


  def func(arg):
      if isinstance(arg, C1):
          return C2()
      else:
          return C1()

  func(C1())
  func(C2())

After running `mod1` module test rope's DOI this way:

``mod2.py``::

  import mod1

  arg = mod1.C1()
  a_var = mod1.func(arg)
  a_var.${codeassist}
  mod1.func(mod1.C2()).${codeassist}


Outline
=======

In tree views (like quick outline and project tree views) you can use
``C-n`` and ``C-p`` to navigate and ``+`` and ``-`` to expand and
collapse items.  You can use the ``Return`` key to select items.


SVN Support
===========

The subversion support is somewhat basic.  What rope does is that when
creating new files or when moving modules and packages for
refactorings it will call the appropriate subversion commands.  The
subversion support is automatically turned on when there is a ``.svn``
folder inside project root and the ``pysvn`` package is
available. (You can get PySVN from http://pysvn.tigris.org ).  Rope
assumes all files are under version control when these conditions are
met.  Also don't forget to commit your changes yourself, rope doesn't
do that yet.

