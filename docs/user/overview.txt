===============
 Rope Features
===============

.. contents:: Table of Contents


Overview
========

The purpose of this file is to give an overview of some of rope's
features.


Code Assist
===========

You can complete names as you type by using code assist (``M-/``).
The two capital letters in the left shows the type of the proposal.
In the first column:

* L: ``local``
* G: ``global``
* A: ``attribute``
* T: ``template``
* K: ``keyword``
* B: ``built-in``

In the second column if present:

* V: ``variable``
* C: ``class``
* F: ``function``
* I: ``imported``
* P: ``paramter``

You can use ``main``, ``testcase``, ``hash``, ``eq`` and ``super``
templates.  If you want to add more or edit these you can edit
`rope.ide.codeassist.PythonCodeAssist._get_default_templates` method.

Completions
-----------

Show PyDoc
----------

Goto Definition
---------------


Refactorings
============

Renaming attributes
-------------------

Consider we have::
  
  class AClass(object):
      
      def __init__(self):
          self.an_attr = 1
      
      def a_method(self, arg):
          print self.an_attr, arg
  
  a_var = AClass()
  a_var.a_method(a_var.an_attr)

After renaming ``an_attr`` to ``new_attr`` and ``a_method`` to
``new_method`` we'll have::
  
  class AClass(object):
      
      def __init__(self):
          self.new_attr = 1
      
      def new_method(self, arg):
          print self.new_attr, arg
  
  a_var = AClass()
  a_var.new_method(a_var.new_attr)


Renaming Function Keyword Parameters
------------------------------------

We have::
  
  def a_func(a_param):
      print a_param
  
  a_func(a_param=10)
  a_func(10)

After performing rename refactoring on any occurance of ``a_param``
we will have::
  
  def a_func(new_param):
      print new_param
  
  a_func(new_param=10)
  a_func(10)


Renaming modules
----------------

Consider the project tree is something like::
  
  root/
    mod1.py
    mod2.py

``mod1.py`` contains::
  
  import mod2
  from mod2 import AClass
  
  mod2.a_func()
  a_var = AClass()

After performing rename refactoring one of the ``mod2`` occurances in
`mod1` we'll get::
  
  import newmod
  from newmod import AClass
  
  newmod.a_func()
  a_var = AClass()

and the new project tree would be::
  root/
    mod1.py
    newmod.py


Extract Method
--------------

The position of the mark would be region start and the current
cursor position would be region end. (You can set the mark as in
emacs copy and paste with ``C-space``). ::
  
  def a_func():
      a = 1
      b = 2 * a
      c = ${region_start}a * 2 + b * 3${region_end}
  
After performing extract method we'll have::

  def a_func():
      a = 1
      b = 2 * a
      c = new_func(a, b)
  
  def new_func(a, b):
      return a * 2 + b * 3


Basic Type Inference
====================

::
  
  class AClass(object):
      
      def __init__(self):
          self.an_attr = 1
      
      def call_a_func(self):
          return a_func()
  
  def a_func():
      return a_func()
  
  a_var = a_func()
  a_var.${codeassist}
  
  another_var = a_var
  another_var.${codeassist}
  another_var.call_a_func().${codeassist}


Dynamic Type Inference
======================

Dynamic type inference gets its needed information from running
modules (``M-X p``).  You open the module to run (probably your test
suite), then use ``M-X p``.  Since as the program runs, rope gathers
type information, the program runs slower.  Right now rope doesn't
have a good interface for running programs.  It just prints the output
to the terminal and does not get inputs.  This will be enhanced in
future releases. After the program is run, you can get better code
assists and some of the refactorings perform much better.

``mod1.py``::

  def f1(param):
      param.${codeassist}
      f2(param).${codeassist}
  
  def f2(param):
      param.${codeassist}
      return param

Using code assist in specified places does not give any information
and there is actually no information about the return type of `f2` or
the parameter `param` of `f1`.

``mod2.py``::
  
  import mod1
  
  class A(object):
      
      def a_method(self):
          pass
  
  a_var = A()
  mod1.f1(a_var)
  
After running `mod2` module using rope's `Run Module`, we get good
code assists in `mod1`.


Outline
=======

In tree views (like quick outline and project tree views) you can use
``C-n`` and ``C-p`` to navigate and ``+`` and ``-`` to expand and
collapse items.  You can use the ``Return`` key to select items.


SVN Support
===========

The subversion support is somewhat basic.  What rope does is that when
creating new files or when moving modules and packages for
refactorings it will call the appropriate subversion commands.  The
subversion support is automatically turned on when there is a ``.svn``
folder inside project root and the ``pysvn`` package is
available. (You can get PySVN from http://pysvn.tigris.org ).  Rope
assumes all files are under version control when these conditions are
met.  Also don't forget to commit your changes yourself, rope doesn't
do that yet.

