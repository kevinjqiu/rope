=========================
 Using Rope As A Library
=========================

If you need other features, send a feature request.  Have a look at
``docs/dev/contributing.txt``.


Making It Work
==============

This section will help you get started as soon as possible.


Make A Project
--------------

The first thing you should do is to make a project::

  import rope.base.project


  myproject = rope.base.project.Project('/path/to/myproject')


Library Utilities
-----------------

The `rope.base.libutils` module provides tools for making using rope
as a library easier.  We'll talk more about this module later.


What Are These `Resource`\s?
----------------------------

In rope each file and folder in a project are accessed through
`rope.base.resources.Resource` objects.  It has two subclasses `File`
and `Folder`.  But what we care about is that refactorings and
`Change`\s (we'll talk about them later) use resources.

In order to create a `Resource` for a path in a project you have two
options.  The first approach uses your `Project` object (Use
`Project.get_resource()`_ method).  I prefer to describe the second
approach since it needs less to know.

We can use `libutils` module.  You can use `path_to_resource()`
function.  It takes a project and a path::

  from rope.base import libutils

  myresource = libutils.path_to_resource(myproject, '/path/to/resource')


But this is only half of the problem.  Consider we have a resource.
How can we know anything about it? The answer is to use its ``path``
and ``real_path`` fields.  `Resource.real_path` is the path of the
resource in the file-system.  The `Resource.path` field contains the
address of a resource relative to project root (The same format as
needed by `Project.get_resource()`_).


Performing Refactorings
-----------------------

There are examples at the end of this document.  But as another
example we'll extract a variable in a file.  First we need the
`Resource` object that points to a file in a project::

  resource = libutils.path_to_resource(myproject, '/path/to/my/module')

So we can make our Refactoring class::

  from rope.refactor.extract import ExtractVariable


  extractor = ExtractVariable(myproject, resource, start, end)

Where `start` and `end` are the offsets of the region to extract in
resource.

Next we need to perform the refactoring.  IDE's usually pop up a
dialog for letting the user configure refactoring option like the name
of the extracted variable.  Next we need to calculate the changes::

  changes = extractor.get_changes('extracted_variable')

`changes` holds the changes this refactoring makes.  It is an instance
of a subclass of `rope.base.change.Change`.


Previewing And Performing Changes
---------------------------------

As mentioned in the last section each refactoring return a
`rope.base.change.Change` object.  Now how can we know what it
contains and how to perform it?

For previewing the changes see the documentation in `rope.base.change`
module.

The easiest way for performing the refactoring is to use
`Project.do()`_ method::

  myproject.do(changes)


If you might want to perform the changes yourself, you have two
options.  Note that the main reason for perform the changes manually
is handling version control systems that are not supported by rope.

The first approach is to use `rope.base.fscommands`_.  See `Writing A
FileSystemCommands`_ section.  The changes can be performed as before
using `Project.do()`.

The other is to perform the changes manually based on the returned
`changes` object (again see the documentation in `rope.base.change`
module).


Validating The Project
----------------------

When using rope as a library you probably change the files in it in
parallel (for example in IDEs).  To force rope to invalidate cached
information about resources that have been removed or changed outside
rope you should call `Project.validate()`_ method.  You should pass a
resource to this method.  For example::

  myproject.validate(myproject.root)

validates all files and directories in the project.  So call this
function every time you use rope (before performing refactorings, for
instance).


Activating Static Object Inference
----------------------------------

One of the great strengths of rope is its static object inference,
SOI.  You can perform SOI on a module using `PyCore.analyze_module()`
method but performing SOI on a module is not cheap.  So we decided
that the best time for performing SOI is whan saving files and only
performing it on changed scopes.

But since rope is not notified about the changes the IDE performs, you
should tell rope about the change.  You can do that by using
`rope.base.libtutils.report_change()`.


Closing The Project
-------------------

Closes project open resources.  Always call this function when you
don't need a project anymore::

  myproject.close()


`rope.base.project.Project`
===========================

You can create a project by::

  project = Project(root_address)

Where the `root_address` is the root folder of your project.

A project has some useful fields.  `Project.address` is the address of
the root folder of a project.  `Project.root` is the `Folder` that
points to the root folder.


`Project.get_resource()`
------------------------

Is for getting a resource (that is file or folder) inside a project.
Uses '/'s for separating directories.  For instance
``project.get_resource('my_folder/my_file.txt')`` returns the a
`rope.base.resources.File` object that points to
``${projectroot}/my_folder/my_file.txt`` file.

Note that this method assumes the resource exists.  If it does not
exist you can use `Project.get_file()` and `Project.get_folder()`
methods.


`Project.do()`
--------------

For committing changes returned by refactorings.


`Project.history`
-----------------

A `rope.base.history.History` object.  You can use its `undo` and
`redo` methods for undoing or redoing changes.


`Project.validate()`
--------------------

When using rope as a library you probably change the files in that
project in parallel (for example in IDEs).  To force rope to
invalidate cached information about resources that have been
removed or changed outside rope you should call `Project.validate`.
You should pass a resource to this method.  For example::

  project.validate(project.root)

validates all files and directories in the project.


`Project.close()`
-----------------

Closes project open resources.  Always call this function when you
don't need a project anymore.  Currently it closes the files used for
storing object information and project history.  Since some parts of
these files are in memory for efficiency not closing a project might
put them in an inconsistent state.


`rope.base.fscommands`
----------------------

The `rope.base.fscommands` module implements the basic file system
operations that rope needs to perform.  The main reason for the
existence of this module is supporting version control systems.  Have
a look at `FileSystemCommands` and `SubversionCommands` in the same
module.  If you need other version control systems you can write a new
class that provides this interface.  `rope.base.project.Project`
accepts a ``fscommands`` argument.  You can use this argument to force
rope to use your new class.


``.ropeproject`` Folder
-----------------------

From version ``0.5m4``, rope makes a ``.ropeproject`` folder in the
project by default for saving project configurations and data.  The
name of this folder is passed to the constructor if you want to change
that.  Also you can force rope not to make such a folder by passing
`None`.

If such a folder exists rope loads the ``config.py`` file in that
folder.  It might also use it for storing object information and
history.


`rope.base.pycore.PyCore`
=========================

Provides useful methods for managing python modules and packages.
Each project has a `PyCore` that can be accessed using
`Project.pycore` attribute.

`PyCore.run_module()` runs a resource.  When running it collects
type information to do dynamic object inference.  For this reason
modules run much slower.



`rope.base.taskhandle.TaskHandle`
=================================

For monitoring the progress and stopping time consuming tasks like
some of the refactorings.



Refactorings
============

Have a look at `rope.refactor` package and its sub-modules.  For
example for performing a move refactoring you can create a
`Move` object like this::

  mover = Move(project, resource, offset)

Where `resource` and `offset` is the location to perform the
refactoring.

Then you can commit the changes by it using `get_changes()` method::

  project.do(mover.get_changes(destination))

Where `destination` module/package is the destination for move refactoring.
Other refactorings classes have a similar interface.


List Of Refactorings
--------------------

Here is the list of refactorings rope provides.  Note that this list
might be out of date.  For more information about these refactoring
see pydocs in their modules and the unit-tests in the
``ropetest/refactor/`` folder.

* `rope.refactor.rename.Rename`:
  Renames something in the project.  See the example below.

* `rope.refactor.move.Move...`:
   Move a python element in the project.

* `rope.refactor.restructure.Restructure`:
  Restructures code.  See the example below.

* `rope.refactor.method_object.MethodObject`:
  Transforms a function or a method to a method object.

* `rope.refactor.extract.Extract...`:
  Extracts methods/variables.

* `rope.refactor.inline.Inline`:
  Inlines occurrences of a method/variable.

* `rope.refactor.change_signature.ChangeSignature`:
  Changes the signature of a function/method.

* `rope.refactor.introduce_factory.IntroduceFactory`:
  Introduces a factory for a class and changes all constructors to use
  it.

* `rope.refactor.introduce_parameter.IntroduceParameter`:
  Introduces a parameter in a function.

* `rope.refactor.encapsulate_field.EncapsulateField`:
  Generates a getter/setter for a field and changes its occurrences to
  use them.

* `rope.refactor.localtofield.LocalToField`:
  Change a local variable to field

* `rope.refactor.ModuleToPackage`:
  Transform a module to a package with the same name.

* `rope.refactor.ImportOrganizer`:
  Lets you perform things like organize imports.


Examples
========

Rename
------

Using rename refactoring::

  # Creating a project
  >>> from rope.base.project import Project
  >>> project = Project('.')

  # Working with files to create a module
  >>> mod1 = project.root.create_file('mod1.py')
  >>> mod1.write('a_var = 10\n')

  # Alternatively you can use `PyCore` objects.
  # Creating modules and packages using `PyCore` objects
  >>> pycore = project.get_pycore()
  >>> pkg = pycore.create_package(project.root, 'pkg')
  >>> mod2 = pycore.create_module(pkg, 'mod2')
  >>> mod2.write('import mod1\nprint mod1.a_var\n')

  # We can use `PyCore.find_module` for finding modules, too
  >>> assert mod2 == pycore.find_module('pkg.mod2')

  # Performing rename refactoring on `mod1.a_var`
  >>> from rope.refactor.rename import Rename
  >>> changes = Rename(project, mod1, 1).get_changes('new_var')
  >>> project.do(changes)
  >>> mod1.read()
  u'new_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.new_var\n'

  # Undoing rename refactoring
  >>> project.history.undo()
  >>> mod1.read()
  u'a_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.a_var\n'

  # Cleaning up
  >>> pkg.remove()
  >>> mod1.remove()
  >>> project.close()


Restructuring
-------------

The example for replacing occurrences of our `pow` function to ``**``
operator (see the restructuring section of `overview.txt`_)::

  # Setting up the project
  >>> from rope.base.project import Project
  >>> project = Project('.')

  >>> mod1 = project.root.create_file('mod1.py')
  >>> mod1.write('def pow(x, y):\n    result = 1\n'
  ...            '    for i in range(y):\n        result *= x\n'
  ...            '    return result\n')
  >>> mod2 = project.root.create_file('mod2.py')
  >>> mod2.write('import mod1\nprint(mod1.pow(2, 3))\n')

  >>> from rope.refactor import restructure

  >>> pattern = '${?pow_func}(${?param1}, ${?param2})'
  >>> goal = '${?param1} ** ${?param2}'

  >>> restructuring = restructure.Restructure(project, pattern, goal)
  >>> checks = {}
  >>> pymod1 = project.get_pycore().get_module('mod1')
  >>> pow_pyname = pymod1.get_attribute('pow')
  >>> checks['?pow_func'] = pow_pyname

  # We could have used `Restructuring.make_checks()` instead:
  # checks = restructuring.make_checks({'?pow_func': 'mod1.pow'})

  >>> project.do(restructuring.get_changes(checks))
  >>> mod2.read()
  u'import mod1\nprint(2 ** 3)\n'
  
  # Cleaning up
  >>> mod1.remove()
  >>> mod2.remove()
  >>> project.close()


See code documentation and test suites for more information.

.. _overview.txt: ../user/overview.html


Other Topics
============


Writing A `FileSystemCommands`
------------------------------

The `get_changes()` method of refactoring classes return a
`rope.base.change.Change` object.  You perform these changes by
calling `Project.do()`.  But as explained above some IDEs need to
perform the changes themselves.

Every change to file-system in rope is commited using an object that
provides `rope.base.fscommands.FileSystemCommands` interface.  As
explained above in `rope.base.fscommands`_ section, rope uses this
interface to handle different VCSs.

You can implement your own fscommands object::

  class MyFileSystemCommands(object):

    def create_file(self, path):
        """Create a new file"""
        # ...

    def create_folder(self, path):
        """Create a new folder"""
        # ...

    def move(self, path, new_location):
        """Move resource at `path` to `new_location`"""
        # ...

    def remove(self, path):
        """Remove resource"""
        # ...

    def write(self, path, data):
        """Write `data` to file at `path`"""
        # ...

And you can create a project like this::

  my_fscommands = MyFileSystemCommands()
  project = rope.base.project.Project('~/myproject',
                                      fscommands=my_fscommands)
