=========================
 Using Rope As A Library
=========================

If you need other features, send a feature request.  Have a look at
``docs/dev/contributing.txt``.


Useful Modules And Classes
==========================

* `rope.base.project.Project`
* `rope.base.pycore.PyCore`
* `rope.refactor`
* `rope.ide.codeassist.PythonCodeAssist`


`rope.base.project.Project`
===========================

You can create a project by::

  project = Project(root_address)

Where the `root_address` is the root folder of your project.
Other interesting methods and attributes that a project
provides:

* `get_resource()`:
  For getting a resource(that is file or folder) inside a project.
  Uses '/'s for separating directories.  For instance
  ``project.get_resource('my_folder/my_file.txt')`` returns the
  ``${projectroot}/my_folder/my_file.txt`` file as a
  `rope.base.project.File` object.
* `root`:
  Returns project root folder resource.
* `get_pycore()`:
  Returns a `rope.base.pycore.PyCore` object.

See code documentation and unit-tests for more.


`Project.do()`
--------------

For committing changes returned by refactorings.


`Project.history`
-----------------

A `rope.base.history.History` object.  You can use its `undo` and
`redo` methods for undoing or redoing changes.


`Project.validate()`
--------------------

When using rope as a library you probably change the files in that
project in parallel (for example in IDEs).  To force rope to
invalidate cached information about resources that have been
removed or changed outside rope you should call `Project.validate`.
You should pass a resource to this method.  For example::

  project.validate(project.root)

validates all files and directories in the project.


`Project.close()`
-----------------

Closes project open resources.  Always call this function when you
don't need a project anymore.  Currently it closes the files used for
storing object information and project history.  Since some parts of
these files are in memory for efficiency not closing a project might
put them in an inconsistent state.


`rope.base.fscommands`
----------------------

The `rope.base.fscommands` module implements the basic file system
operations that rope needs to perform.  The main reason for the
existence of this module is supporting version control systems.  Have
a look at `FileSystemCommands` and `SubversionCommands` in the same
module.  If you need other version control systems you can write a new
class that provides this interface.  `rope.base.project.Project`
accepts a ``fscommands`` argument.  You can use this argument to force
rope to use your new class.


``.ropeproject`` Folder
-----------------------

From version ``0.5m4``, rope makes a ``.ropeproject`` folder in the
project by default for saving project configurations and data.  The
name of this folder is passed to the constructor if you want to change
that.  Also you can force rope not to make such a folder by passing
`None`.

If such a folder exists rope loads the ``config.py`` file in that
folder.  It might also use it for storing object information and
history.


`rope.base.pycore.PyCore`
=========================

Provides useful methods for managing python modules and packages.
Each project has a `PyCore` that can be accessed using
`Project.pycore` attribute.

`PyCore.run_module()` runs a resource.  When running it collects
type information to do dynamic object inference.  For this reason
modules run much slower.


Refactorings
============

Have a look at `rope.refactor` package and its sub-modules.  For
example for performing a move refactoring you can create a
`Move` object like this::

  mover = Move(project, resource, offset)

Where `resource` and `offset` is the location to perform the
refactoring.

Then you can commit the changes by it using `get_changes()` method::

  project.do(mover.get_changes(destination))

Where `destination` module/package is the destination for move refactoring.
Other refactorings classes have a similar interface.


Examples
========

Rename
------

Using rename refactoring::

  # Creating a project
  >>> from rope.base.project import Project
  >>> project = Project('.')

  # Working with files to create a module
  >>> mod1 = project.root.create_file('mod1.py')
  >>> mod1.write('a_var = 10\n')

  # Alternatively you can use `PyCore` objects.
  # Creating modules and packages using `PyCore` objects
  >>> pycore = project.get_pycore()
  >>> pkg = pycore.create_package(project.root, 'pkg')
  >>> mod2 = pycore.create_module(pkg, 'mod2')
  >>> mod2.write('import mod1\nprint mod1.a_var\n')

  # We can use `PyCore.find_module` for finding modules, too
  >>> assert mod2 == pycore.find_module('pkg.mod2')

  # Performing rename refactoring on `mod1.a_var`
  >>> from rope.refactor.rename import Rename
  >>> changes = Rename(project, mod1, 1).get_changes('new_var')
  >>> project.do(changes)
  >>> mod1.read()
  u'new_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.new_var\n'

  # Undoing rename refactoring
  >>> project.history.undo()
  >>> mod1.read()
  u'a_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.a_var\n'

  # Cleaning up
  >>> pkg.remove()
  >>> mod1.remove()
  >>> project.close()


Restructuring
-------------

The example for replacing occurrences of our `pow` function to ``**``
operator (see the restructuring section of `overview.txt`_)::

  # Setting up the project
  >>> from rope.base.project import Project
  >>> project = Project('.')

  >>> mod1 = project.root.create_file('mod1.py')
  >>> mod1.write('def pow(x, y):\n    result = 1\n'
  ...            '    for i in range(y):\n        result *= x\n'
  ...            '    return result\n')
  >>> mod2 = project.root.create_file('mod2.py')
  >>> mod2.write('import mod1\nprint(mod1.pow(2, 3))\n')

  >>> from rope.refactor import restructure

  >>> pattern = '${?pow_func}(${?param1}, ${?param2})'
  >>> goal = '${?param1} ** ${?param2}'

  >>> restructuring = restructure.Restructure(project, pattern, goal)
  >>> checks = {}
  >>> pymod1 = project.get_pycore().get_module('mod1')
  >>> pow_pyname = pymod1.get_attribute('pow')
  >>> checks['?pow_func'] = pow_pyname

  # We could have used `Restructuring.make_checks()` instead:
  # checks = restructuring.make_checks({'?pow_func': 'mod1.pow'})

  >>> project.do(restructuring.get_changes(checks))
  >>> mod2.read()
  u'import mod1\nprint(2 ** 3)\n'
  
  # Cleaning up
  >>> mod1.remove()
  >>> mod2.remove()
  >>> project.close()


See code documentation and test suites for more information.

.. _overview.txt: ../user/overview.html


Using Rope In Other IDEs
========================

In normal situation its as easy as described above.  But the problem
happens when both Rope and the IDE need to know or possibly perform
the changes that the other needs to perform.


Outgoing Changes
----------------

Outgoing changes are the changes required by refactorings.  The
`get_changes()` method of refactoring classes return a
`rope.base.change.Change` object.  You perform these changes by
calling `Project.do()`.  But as explained above some IDEs need to
perform the changes themselves.

Every change to file-system in rope is commited using an object that
provides `rope.base.fscommands.FileSystemCommands` interface.  As
explained above in `rope.base.fscommands`_ section, rope uses this
interface to handle different VCSs.

You can implement your own fscommands object::

  class MyFileSystemCommands(object):

    def create_file(self, path):
        """Create a new file"""
        # ...

    def create_folder(self, path):
        """Create a new folder"""
        # ...

    def move(self, path, new_location):
        """Move resource at `path` to `new_location`"""
        # ...

    def remove(self, path):
        """Remove resource"""
        # ...

    def write(self, path, data):
        """Write `data` to file at `path`"""
        # ...

And you can create a project like this::

  my_fscommands = MyFileSystemCommands()
  project = rope.base.project.Project('~/myproject',
                                      fscommands=my_fscommands)


Incoming Changes
----------------

These are the changes that are performed by the IDE.  Rope needs to
know the changes in order to update its cached data.  Also some useful
features of rope are activated when changing the project.  For example
when a file is saved static object inference is performed on the
changed scopes.  Also project history records file changes and that is
useful if you want to be able to undo and redo the changes.

But if you don't care about these features you can use
`Project.validate()`_ as described above.  But I don't recommend it.

...


Previewing Changes
------------------

...
