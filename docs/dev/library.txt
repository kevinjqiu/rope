=========================
 Using Rope As A Library
=========================

If you need other features, send a feature request.  Have a look at
``docs/dev/contributing.txt``.


Useful Modules And Classes
==========================

* `rope.base.project.Project`
* `rope.base.pycore.PyCore`
* `rope.refactor`
* `rope.ide.codeassist.PythonCodeAssist`


`rope.base.project.Project`
===========================

You can create a project by::

  project = Project(root_address)

Where the `root_address` is the root folder of your project.
Other interesting methods and attributes that a project
provides:

* `get_resource()`:
  For getting a resource(that is file or folder) inside a project.
  Uses '/'s for separating directories.  For instance
  ``project.get_resource('my_folder/my_file.txt')`` returns the
  ``${projectroot}/my_folder/my_file.txt`` file as a
  `rope.base.project.File` object.
* `root`:
  Returns project root folder resource.
* `get_pycore()`:
  Returns a `rope.base.pycore.PyCore` object.

See code documentation and unit-tests for more.


`Project.do`
------------

For committing changes returned by refactorings.


`Project.history`
-----------------

A `rope.base.history.History` object.  You can use its `undo` and
`redo` methods for undoing or redoing changes.


`Project.validate`
------------------

When using rope as a library you probably change the files in that
project in parallel (for example in IDEs).  To force rope to
invalidate cached information about resources that have been
removed or changed outside rope you should call `Project.validate`.
You should pass a resource to this method.  For example::

  project.validate(project.root)

validates all files and directories in the project.


`rope.base.fscommands`
----------------------

The `rope.base.fscommands` module implements the basic file system
operations that rope needs to perform.  The main reason for the
existence this module is supporting version control systems.  Have a
look at `FileSystemCommands` and `SubversionCommands` in the same module.
If you need other version control systems you can write a new class
providing this interface.  `rope.base.project.Project` accepts a
``fscommands`` argument.  You can use this argument to force rope to
use your new class.


`rope.base.pycore.PyCore`
=========================

Provides useful methods for managing python modules and packages.
Each project has a `PyCore` that can be accessed using
`Project.pycore` attribute.

`PyCore.run_module()` runs a resource.  When running it collects
type information to do dynamic object inference.  For this reason
modules run much slower.


Refactorings
============

Have a look at `rope.refactor` package and its sub-modules.  For
example for performing a move refactoring you can create a
`Move` object like this::

  mover = Move(project, resource, offset)

Where `resource` and `offset` is the location to perform the
refactoring.

Then you can commit the changes by it using `get_changes()` method::

  project.do(mover.get_changes(destination))

Where `destination` module/package is the destination for move refactoring.
Other refactorings classes have a similar interface.


A Sample Session
================

Here is a sample session.::

  # Creating a project
  >>> from rope.base.project import Project
  >>> project = Project('.')

  # Working with files to create a module
  >>> mod1 = project.root.create_file('mod1.py')
  >>> mod1.write('a_var = 10\n')

  # Alternatively you can use `PyCore` objects.
  # Creating modules and packages using `PyCore` objects
  >>> pycore = project.get_pycore()
  >>> pkg = pycore.create_package(project.root, 'pkg')
  >>> mod2 = pycore.create_module(pkg, 'mod2')
  >>> mod2.write('import mod1\nprint mod1.a_var\n')

  # We can use `PyCore.find_module` for finding modules, too
  >>> assert mod2 == pycore.find_module('pkg.mod2')

  # Performing rename refactoring on `mod1.a_var`
  >>> from rope.refactor.rename import Rename
  >>> changes = Rename(pycore, mod1, 1).get_changes('new_var')
  >>> project.do(changes)
  >>> mod1.read()
  u'new_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.new_var\n'

  # Undoing rename refactoring
  >>> project.history.undo()
  >>> mod1.read()
  u'a_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.a_var\n'

  >>> pkg.remove()
  >>> mod1.remove()

See code documentation and test suites for more information.
