=========================
 Using Rope As A Library
=========================

By ``0.4`` release *rope* would probably be ready for being used as a
library.  Features that need to be added include:

Done:

* Updating files that are changed outside rope
* Better support for other version control systems
* Considering tabs to be 8 spaces

To be done?:

* Having a list of ignored file and folder patterns
* Extending and having more control on file reading and writing
* Limiting memory usage; throwing away calculated information when low
  on memory
* Documenting published interfaces

If you need other features, send a feature request.  Have a look at
``docs/dev/contributing.txt``.


Useful Classes
==============

* `rope.base.project.Project`
* `rope.base.pycore.PyCore`
* `rope.refactor.PythonRefactoring`
* `rope.refactor` sub-modules
* `rope.ide.codeassist.PythonCodeAssist`


`rope.base.fscommands`
======================

The `rope.base.fscommands` module implements the basic file system
operations that rope needs to perform.  The main reason for the
existence this module is supporting version control systems.  Have a
look at `FileSystemCommands` and `SubversionCommands` in the same module.
If you need other version control systems you can write a new class
providing this interface.  `rope.base.project.Project` accepts a
``fscommands`` argument.  You can use this argument to force rope to
use your new class.


`rope.base.project.Project.validate`
====================================

When using rope as a library you probably change the files in that
project in parallel (for example in IDEs).  To force rope to
invalidate cached information about resources that have been
removed or changed outside rope you should call `Project.validate`.
You should pass a resource to this method.  For example::

  project.validate(project.get_root_folder())

validates all files and directories in the project.


A Sample Session
================

Here is a sample session.::

  # Creating a project
  >>> from rope.base.project import Project
  >>> project = Project('.')

  >>> pycore = project.get_pycore()
  >>> refactoring = project.get_pycore().get_refactoring()

  # Working with files to create a module
  >>> root = project.get_root_folder()
  >>> mod1 = root.create_file('mod1.py')
  >>> mod1.write('a_var = 10\n')

  # Creating modules and packages using `PyCore` objects
  >>> pkg = pycore.create_package(root, 'pkg')
  >>> mod2 = pycore.create_module(pkg, 'mod2')
  >>> mod2.write('import mod1\nprint mod1.a_var\n')

  # We can use `PyCore.find_module` for finding modules, too
  >>> assert mod2 == pycore.find_module('pkg.mod2')

  # Performing rename refactoring on `mod1.a_var`
  >>> from rope.refactor.rename import RenameRefactoring
  >>> changes = RenameRefactoring(pycore, mod1, 1).get_changes('new_var')
  >>> refactoring.add_and_commit_changes(changes)
  >>> mod1.read()
  u'new_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.new_var\n'

  # Undoing rename refactoring
  >>> refactoring.undo()
  >>> mod1.read()
  u'a_var = 10\n'
  >>> mod2.read()
  u'import mod1\nprint mod1.a_var\n'

  >>> pkg.remove()
  >>> mod1.remove()

See code documentation and test suites for more information.
