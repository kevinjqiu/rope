=============
 Rope Issues
=============


Release Schedule
================

*rope* will be released every two weeks and each quarter a final
version would be released.  That is:

=======  ===============
Week #   Release Name
=======  ===============
2        x.ym1
4        x.ym2
6        x.ym3
8        x.ym4
10       x.ym5
12       x.ym6
13       x.y
=======  ===============

This is only a rough plan.  For example we might have 1-week release
candidates before the ``x.y``.


Version 0.6
===========

From May 7, 2007 till August 5, 2007


Release Goals
-------------

Metaphor: Supporting restructurings

Other Possible Goals:

* Finding similar pieces to extracted
* Formatting?


Release Issues
--------------

Rope has dropped Python 2.4 support in this release.


Hot Topics
==========

* `Releasing library package`_


To Be Discussed
===============

* `Memory management`_
* `Getting ready for Python 3.0`_
* Should `rope.base` be thread safe? which parts?


Cache Invalidation And Parameter Cache
======================================

`PyFunction` holds a cache of is parameters.  The reason this cache is
not moved to the `ParameterName` is that in SOI we need to set the
parameters and then we start analyzing the return value.

The main problem with this approach is that the cache references other
modules and python elements.  I think this happens because SOI might
analyze calls in the reverse order of imports.  But fixing it needs
lots of work and maybe changing rope considerably.

We should use an approach that:

* Never should allow access an invalidated object
* Does not stop garbage collection from freeing invalidated objects
* Should be easy to test

The current approach fails in all of these.


How `_ConcludedData` Is Used
----------------------------

* Concluded attributes in `PyDefinedObject` -> list of `PyName`
* Parameter pyobject cache in `PyFunction` -> list of `PyObject`
* Superclasses in `PyClass` -> list of `PyObject`

* Pyobject in `AssignedName` -> `PyObject`
* Pyobject in `EvaluatedName` -> `PyObject`
* Imported pymodule in `ImportedModule` -> `PyObject`


Issues
------

We should be able to handle this:

mod1::

  class A(object):
      pass


mod2::

  import mod1

  B = mod1.A


mod3::

  import mod2

  var = mod2.B()

Now if we change mod2::

  class B(object):
      pass

If we only care about the pyobject this will fail.  That's because
although `mod1.A` is valid, `var` should be an instance of `mod2.B`
and not `mod1.A`.

So it seems we're merely adding another check to pyobject refs.  This
new check can be done in two ways; We can either use weak refs and
check every access to a pyobject or we can add register for
invalidation in destination module.  Yet this does not solve all
problems.  We should know what `PyDefinedObject`\s a pyobject
references and for builtins this might be more than one.  What's more
we should handle references in pymodules and a reference might be
referenced by more than one pymodule.

Actually there are two separate issues:

* Invalidating based on definition location
* Invalidating based on the referenced `PyDefinedObject`\s

The former is already handled.  But the other problem exists mainly
because of SOI.


Adding `PyModule.register_invalidation_observer()`
--------------------------------------------------

How can this solve invalidation problems? How is it different from
concluded data?

This can be used to handle situations where there are references to a
list of objects.

* When an observer was informed it should be removed from the list of
  observers


Adding `PyModule.is_valid()`
----------------------------

This requires introducing `_PyObjectRef`, `_PyNameRef`, and probably
`_PyObjectListRef`.  We'll also be able to remove the list of
concluded objects in `PyModule`.  These objects should use weak
references.

But this does not seem to work::

  class DependentRef(object):
      """The data remains valid as long as the dependency remains valid"""

      def __init__(self, dependency=None, data=None):
          self.dependency = weak(dependency)
          self.data = weak(data)

      def get(self):
          if self._is_dependency_valid():
              return self.data
          self.data = None


  class PyObjectRef(object):

      def __init__(self, pyobject=None):
          self.data = weak(data)

      def get(self):
          if self.is_valid(self.data):
              return self.data
          self.data = None


Invalidating Imported Modules In Both Directions
------------------------------------------------

If other approaches fails I have to use this.  We have to handle
loops, by the way.


Better Concluded Data
=====================

The main problem is when using star imports, after a module has been
invalidated its concluded data still exist.  This does not seem to be
a major memory leak, since these `_ConcludedData`\s are invalidated
and contain `None`.

* Using weak references for holding concluded data
* Changing `ImportedName` not to store the imported object in a
  concluded data.  This might slow things a bit.
* Changing `StarImport` to use a mock concluded data for its
  `ImportedModule` and `ImportedName`\s

The other suggestion here is that currently `ImportedName`\s store
object information in the concluded data of the importing module while
they can get concluded data from imported module.  The problem happens
when the imported module gets deleted.

Note that concluded attributes are:

* PyClass: superclass attributes
* PyModule: star imports
* PyPackage: ``__init__.py`` attributes


Releasing Library Package
=========================

As it is written in ``README.txt`` file the initial goal of rope was
to release a library if it achieved its goals:

  The type inference and refactoring parts will not be dependent on
  *rope* IDE and if successful, will be released as standalone
  programs and libraries so that other projects may use them.

I think it is now the time.

* A new ``setup.py`` for making and registering library package
* The library package will contain `rope`, `rope.base`, and
  `rope.refactor` packages
* The name of packages: using ``rope`` for the library and
  ``ropeide`` for the IDE

Issues:

* Two separate ``README.txt`` files?
* Should the IDE contain the library?
* Separating common, library, and IDE documents


Memory Management
=================

These are the places in which rope spends most of the memory it
consumes:

* PyCore: for storing PyModules
* ObjectInfo: for storing object information
* History: for storing changes

We should measure the amount of memory each of them uses to make
decisions.


Getting Ready For Python 3.0
============================

Unfortunately it seems impossible to make rope both a valid Python 2.x
and 3.x program.  Possible approaches are having two separate branches
of rope (that I strongly resist) or moving from 2.x to 3.x gradually.

For making transition to 3.x easier rope has already started using
`_ast` module instead `compiler`.

* Updating `rope.refactor.patchedast` module for using new nodes
* Updating `rope.base.evaluate`
* Updating `rope.base.builtins`
* Changing `rope.refactor.funcutils` to handle keyword only args
* Changing print to function in tests
* Not supporting old relative imports
* `iter.__next__()` instead of `iter.next()`?
* Supporting `bytes`, `input`
* Removing nonexistent dict methods and methods that will return sets
* Chaning imports after library reorganization
* Show function annotations in pydocs
* ``nonlocal``
* ``except xxx as yyy``
* Supporting keyword only arguments
* Set literals and comprehension ``{1, 2, 3}`` and ``{x for x in range(10)}``
* Renamed function attributes; ``f.func_whatever`` to ``f.__whatever__``
* Use new function signature
* Not using ``__cmp__``
* Updating integer and string literal patterns


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In future some of this restrictions might be
removed.

* All files that end with ``.py`` are considered to be python files
  and all others not.
* Either all files that are not ignored should be under version
  control or none.
* All ``*.txt`` files are considered to be ReST.
* XXX


Object Inference Issues
=======================


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself, too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed we should make some difference between the objects that we
only care about their types and the objects that their individual
instance is important to us.  Right now the latter group contains
only functions, classes, modules, lists, dicts and sets but this
list will be probably extended.


The GUI Mess; Working More on the UI Parts
==========================================


Version Control Commands
------------------------

* Commit; ``C-x v c``
* Update; ``C-x v u``
* Diff; ``C-x v d``
* Log; ``C-x v l``
* Revert; ``C-x v r``
* Remove; ``C-x v v``
* Status; ``C-x v s``
* Add; ``C-x v a``
* Blame; ``C-x v b``


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?
