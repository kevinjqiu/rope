=============
 Rope Issues
=============


Release Schedule
================

*rope* will be released every two weeks and each quarter a final
version would be released.  That is:

=======  ===============
Week #   Release Name
=======  ===============
2        x.ym1
4        x.ym2
6        x.ym3
8        x.ym4
10       x.ym5
12       x.yrc1
13       x.y
=======  ===============

This is only a rough plan.  For example we might have more release
candidates before the ``x.y`` release.


Version 0.5
===========

From February 4, 2007 till May 6, 2007


Release Goals
-------------

Metaphor: Better static object inference

* Enhancing old refactorings
* Enhancing UI


Discussion
----------

Now that we handle many kinds of refactorings and we have achieved
many of rope's initial goals we can think of extending it.

There are many places to extend rope.  There are two main places that
can be enhanced.  One is occurrence finding mechanisms and the other
is object inference.  Among the features that are going to be added
implicit interfaces and changing structure refactorings are the most
promising ones.

* Occurrence finding
* DOI
* SOI
* Implicit interfaces
* Changing structure refactorings; like ``a = b`` -> ``a.set(b)``
* Advanced refactorings


Hot Topics
==========



To Be Discussed
===============

* `Memory management`_
* `Better occurrence finding`_
* `Getting ready for Python 3.0`_
* `Python's implicit interfaces`_
* Decorators and method refactorings
* Should `rope.base` be thread safe? which parts?
* Indexing source files for faster occurrence finding
* Faster module running
* Saving hard to compute information like class hierarchies to files
* Finding available refactorings


Memory Management
=================

These are the places in which rope spends most of the memory it
consumes:

* PyCore: for storing PyModules
* ObjectInfo: for storing object information
* History: for storing changes

We should measure the amount of memory each of them uses to make
decisions.


Better SOI
==========

I don't know how often and when to scan a module for SOI.  Maybe
before ``0.5`` release, rope only performs SOI when the user asks;
just like DOI.  Performing it automatically requires it to be
efficient.  So later, after using it for some time, we'll decide about
that.


Automatic SOI
-------------

Performing SOI when saving:

* The order in which observers are called
* Not analyzing everytime?
* ``automatic_soi`` project config

Unfortunately performing SOI whenever a buffer is saved is not cpu and
memory efficient.  One way to solve this problem is to hold a new
variable for each scope.  This variable will hold the has of the
contents of that scope.  When a project changes only those scope whose
contents have changed will be analyzed.  The main problem with this
approach is that scopes are nested and when an inner scope changes all
its parents change, too.


Returned Object SOI
-------------------

Since we're passed the objects parameters hold, we can perform a
better returned object SOI.  We can do that by giving parameter
objects passed and infer the object of local names once more.

Actually we have to perform two things.  We have to ask scope
`PyName`\s to forget their concluded data and change the parameters to
return what we want.

So to make it we have:

* Used `PyFunction._set_parameter_pyobjects()` to set the type
  of parameters
* Added `FunctionScope.invalidate_data()` to invalidate the
  pyobjects `AssignedName`\s and `EvaluatedName`\s hold.

And after implementing these we thought of treating function scopes
specially, since the names there cannot be accessed from outside.


Function Scopes
---------------

Another issue for implementing this feature is that function scope
variable types are dependent on the type of the parameters and should
change.  This issue seem to have some relations with implicit
interfaces.

These two problems(in the above section) points us to treating
function scopes specially.  Since function names are not accessible
from outside that function, we can perform all calculations in a
temporary place.

The problem gets worse when there are defined objects in a function
scope.  Maybe we can change pynames to support function scopes.


Enhancing `ObjectInfoManager`
=============================

* Not saving return value in callinfo when we're approximating?
* Should every unknown be calculated everytime?
* Changing `callinfo` to match similar args
* Saving python elements with no source; `Abstract...`
* When to forget old results?
* Some `self`\s are unknown!
* Updating our db when performing refactorings like move module
* Returning a `Generator` for generator functions with unknown return type?
* Validating call infos


Validating Information
----------------------

When do we need to recalculate the information? Currently rope does
not save anything unless an exact object is calculated; in that case
it will be used until they remain valid.  The problems with this
approach includes:

* The method might be changed in future.

  * Returned object
  * Parameter objects
  * The number of parameters

* We don't want to recalculate 'unknown's and 'none's every time
* The methods or data accessed by the method might change

The need for invalidating data is felt more after saving object data
to disk.


Saving Data On Disk
-------------------

There are two main reasons for saving object information on disk.  One
is that we can use these information in future sessions.  The other is
holding all type information in memory needs a lot of memory.

* ``shelvedb``:

  This has been implemented in ``0.5m4``.

* ``sqlite3db``:

  This requires having `sqlite3`.  Fortunately it is included in
  standard library since ``2.5``.  We can have these tables:

  * scope: path, key
  * call_info: scope_fk, args, returned
  * per_name: scope_fk, name, value


Saving object data requires having good mechanisms for invalidating
information and testing.


Task `Progress`
===============

Currently refactorings cannot be stopped.  I propose to add an object
for stopping and showing the progress of a time consuming task::

  class TaskHandle(object):

      def stop(self):
          pass

      def is_stopped(self):
          pass

      def get_progress(self, total=None):
          pass

  class Progress(object):

      def done(self, count):
          pass

      def set_task(self, name):
          pass

It requires adding an argument to all refactorings and other time
consuming tasks and changing them to use this object.  Alternatively
we can change `TaskHandle` to have a method like `done(percent)`
method that checks whether it is stopped and raises exceptions if it
is.


Better Concluded Data
=====================

The main problem is when using star imports, after a module has been
invalidated its concluded data still exist.  This does not seem to be
a major memory leak, since these `_ConcludedData`\s are invalidated
and contain `None`.

* Using weak references for holding concluded data
* Changing `ImportedName` not to store the imported object in a
  concluded data.  This might slow things a bit.
* Changing `StarImport` to use a mock concluded data for its
  `ImportedModule` and `ImportedName`\s

The other suggestion here is that currently `ImportedName`\s store
object information in the concluded data of the importing module while
they can get concluded data from imported module.  The problem happens
when the imported module gets deleted.

Note that concluded attributes are:

* PyClass: superclass attributes
* PyModule: star imports
* PyPackage: ``__init__.py`` attributes


Marking Errors And Warnings In GUI
==================================

* Marking the occurrence in the buffer
* When to analyze the code?

  * When the user asks
  * When saving

* Saving error/warning information
* ``C-,``, ``C-.``
* ``C-c a p``, ``C-c a n``


Better Occurrence Finding
=========================

The current implementation for finding occurrences of a `PyName` is to
test every textual occurrence of that name has the same `PyName` or
not.  This approach does not work when a name is repeated many times
in the source.  For example renaming `self`\s are very time consuming.

Maybe we can use one of these solutions:

* Checking pyname equality only once for each scope

  This way we check each name only once for each scope.  But this is
  not applicable for attributes.  What's more `PyName`\s seem to
  cache their types already.

* Limiting the places to search for a name

  For example for renaming a parameter we search the body of that
  function and the keyword arguments passed to functions.  As another
  example function parameters never appear as attributes and class
  variables and methods never are referenced directly except in class
  body.  The search locations include:

  * module bodies
  * class bodies
  * function bodies

  Access methods include:

  * function call keyword
  * normal name access
  * attribute access

* Excluding unimported modules

  This does not seem to be a good solution.  One reason is that the
  imports might be indirect.  So we have to put a long time for
  creating import trees.

Or maybe we can use a strategy object for searching.


Getting ready for Python 3.0
============================

* Changing print to function in tests
* Not supporting old relative imports
* `iter.__next__()` instead of `iter.next()`?
* Supporting `bytes`, `input`
* Removing nonexistent dict methods and methods that will return sets
* Chaning imports after library reorganization
* Show function annotations in pydocs
* ``nonlocal``
* ``except xxx as yyy``
* ``...``
* Supporting keyword only arguments
* Set literals and comprehension ``{1, 2, 3}`` and ``{x for x in range(10)}``
* Renamed function attributes; ``f.func_whatever`` to ``f.__whatever__``
* Use new function signature
* Not using ``__cmp__``


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In futures some of this restrictions might be removed.

* All files that end with ``.py`` are considered to be python files and
  all others not.
* Either all files should be under version control or none.
* All ``*.txt`` files are considered in reST formats.
* XXX


Object Inference Issues
=======================


Rejecting Smalltalk `RefactoringBrowser` Approach
-------------------------------------------------

We can't use smalltalks approach because it requires the whole
tests suite to be run before each refactoring and this does not
seem appealing because it might take a lot of time.

Apart from that if we use a wrapper for a function using python
runtime mechanisms it is possible to find out from which line
a function is called, but we cannot always find the offset in that
file from which this function is called.

Although we cannot find the exact offset an occurrence happens we
can know the suspected lines and that will help us shorten the
scope for searching for occurrences considerably.

If we solve these problems we can use a strategy for finding
occurrences.  Also Think of other ways of collecting type information.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself, too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed we should make some difference between the objects that we
only care about their types and the objects that their individual
instance is important to us.  Right now the latter group contains
only functions, classes, modules, lists, dicts and sets but this
list will be probably extended.


Python's Implicit Interfaces
============================

Basic Implicit Interfaces
-------------------------

There are many dark points about these interfaces, but we should start
from somewhere.


Overview
--------

In python you don't have to define interfaces to declare that classes
use a specific protocol or interface.  There are lots of such examples
in standard library.

For example::

  class A(object):

      def a_method(self):
          pass

  class B(object):

      def a_method(self):
          pass

  def a_func(arg):
      arg.a_method()

  a_func(A())
  a_func(B())

Here although there is no inheritance relations between `A` and `B`,
renaming `A.a_method` should force `B.a_method` to be renamed too.

Or as another example::

  a_var = A()
  a_var.a_method()

renaming `a_var.a_method` should rename both `A.a_method` and
`B.a_method`.  That is `a_func` function defines the interface and its
members.

Now the problem is, if rope wants to support implicit interfaces, how
should it find out these interfaces and their members.


Not Supporting Implicit Interfaces
----------------------------------

If we plan not to support implicit interfaces things simplify
considerably.  Function arguments objects are the common base class
of encountered arguments and function returned value object is the
common base class of returned values.


Supporting Implicit Interfaces
------------------------------

We need to find out the way these implicit interfaces are defined.
Actually each function defines an interface for each of its parameters
and the members of this interface are the objects that are passed as
that argument.  Another thing to keep in mind is that implicit
interfaces are extended by inheritance relation, too.  For example::

  class C(A):

      def a_method(self):
          pass

  def a_func(arg):
      arg.a_method()

  another_func(C())

Renaming `arg.a_method` not only should rename `C.a_method` but also
it should rename `A.a_method`.

We should be careful about situations like::

  def a_func(arg):
      if isinstance(arg, A):
          arg.do_something()
      else:
          arg.do_some_other_thing()

The other issue is what to do for situations like this::

  def a_func(obj1, obj2):
      result = obj1.f(obj2)
      result.g()

The problem is we don't know the types of `obj1` and `obj2` exactly
and we have a list of types that these variables are assigned during
program execution.  `obj1.f` is not a specific method.


Implementation Issues
---------------------

To support implicit interfaces we need to make lots of changes.  First
of all we know that a function parameter can be anything, so using DOI
we have a set of objects for each parameter.  So the question that
comes up here is when do we need parameter objects.

* When refactoring and finding occurrences
* When code assisting in a function

Also for a rename refactoring we need to check all functions and methods
for implicit interfaces that are involved.  This does not seem practical.
Find someway of making it possible.  Maybe we can find
all of the occurrences of a method and for each check whether it is
invoked on a parameter or not.  Now that we have a bigger set of
methods we need to do the same for these methods.  When we're finished
we can perform the actual refactoring.  The challenge here is that we
should consider inheritance relations, too.

Among `PyName` classes `AssignedName`, `ParameterName` and
`ImportedName` might have more than one object.  And I believe
the main place to change is `StatementEvaluator` that might
return a list of pynames in ``${attribute_accesses}.name``
where `attribute_accesses` might result in more than one kind
of pyname.  This implies that `get_pyname_at` might return a list
of pynames.

`objectinfer` should be changed to find all of the objects that can
be inferred.


The GUI Mess; Working More on the UI Parts
==========================================


Version Control Commands
------------------------

* Commit; ``C-x v c``
* Update; ``C-x v u``
* Diff; ``C-x v d``
* Log; ``C-x v l``
* Revert; ``C-x v r``
* Remove; ``C-x v v``
* Status; ``C-x v s``
* Add; ``C-x v a``
* Blame; ``C-x v b``


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?
