=============
 Rope Issues
=============


Release Schedule
================

*rope* will be release every two weeks and one final release every
quarter.  That is

=====  ===============
Week   Release Number
=====  ===============
2      x.ym1
4      x.ym2
6      x.ym3
8      x.ym4
10     x.ym5
12     x.yrc1
13     x.y
=====  ===============

This is only a rough plan.  For example some more release candidates
might be released before the ``x.y`` release.


Version 0.4
===========

From November 6, 2006 till February 4, 2007


Release Goals
-------------

Metaphor: Enhance features and make rope extensible


Release Goals
-------------

* Rope library


Possible Plans
--------------

* Inline method
* Move field/methods
* Change method signature
* Handling built-in types
* Implicit interfaces
* High level refactorings


Hot Topics
==========

* Using DOI for inline method and change method signature


To Be Discussed
===============

* `Library Movement`_
* `Function Tools`_
* `Python's Implicit Interfaces`_
* Rope's preference saving system: format, location
* Indexing source files for faster occurrence finding
* Having a persistant format for PyNames and PyObjects for saving
  hard to compute information like class hierarchies
* Using a modification of `compiler` AST for simplifying refactorings
* Undo Unification


Supporting Built-in Types
=========================

The main motive for supporting built-in types are `list`, `dict` and
`set`.  We try to start with the simplest of these; `list` types.


Supporting `list`
-----------------

It is relatively easy to support `list` as being a type with some
functions, but the main motive for supporting `list`\s are providing
meaningful return values from its functions such as `__index__` or
providing correct variables in for loops.  To do these we assume that
every list only contains one type of objects.

* How should we infer the type an iterator holds?

One way of doing this is object inference of `list.append` or other
insertion functions.  But the difficulty here is we should infer
the parameters of these functions for each instance in program source
rather than for the list type in whole.  First of all this analysis
should be performed at runtime.

* `ObjectInfer.infer_holding_type` for `iterator`\s
* Addition of a flag to types that indicates the distinction of
  instances.
* Can we support `iterator` types, too?


Inline Method
=============

* Which of the variables should be renamed?
* What to do about parameter assignments?
* What to do about staticmethod an classmethods decorators
* Moving used imports and importing defining module globals
* Inlining generators
* Inner functions

What to do for::

  def func():
      print 'hey'
  
  f = func
  f()

Should we inline `f`?  Can we use dynamically gathered information
for this purpose?  Fortunately this case never happens because rope
does not allow the inlining functions to be assigned to other names
and it throws an exception in those cases.


Library Movement
================

* Updating files that have changed on disk
* Removing 4-space indentation assumption
* Removing tabs
* Changing `rope.base.fscommands` for projects
* Adding `read` and `write` to `rope.base.fscommands`
* Should we expect files to be changed inside or outside the project?


Updating Changed Files
----------------------

We can add a `Project.update` method that should be called each
time we use rope classes.  But this seems inefficient if the
number of updates are high.  We might be able to pass the
changing file or folder to this method.  We can use this update in
`fscommands` for moving and removing files, too.

The other issue that might occur when using rope is that a file
might detect that it has been changed or its path does not exist.
What should we do in these situations?


Function Tools
==============

Hava a look at `inline._CallAnalyzer`.

* Adding parameters
* Removing parameters
* Renaming parameters
* Change the order of parameters
* Inline parameter default value
* Sort and normalize passed call parameters;
  a_func(p2=v2, p1=v1, p3=v3) -> a_func(v1, v2, p3=v3)


Using ASTs For Transformations
==============================

The main problem with AST nodes is that they only hold the line in
which statements appear but we need the offset.  If we add offset
information to AST nodes, we would be able to use them for all of the
tasks that we do right now using direct operations on program source
code.

Using ASTs for transforming programs requires making a new AST tree
or altering the old one and writing AST trees.  We can use the latter
in the formatter, too but it seems a lot of work.


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In futures some of this restrictions might be removed.

* All of the modules should use 4 spaces for indenting and no hard tabs.
* All files that end with ``.py`` are considered to be python files and
  all others not.
* Either all files should be under version control or none.
* All ``*.txt`` files are considered in reST formats.
* XXX


Designing Refactorings to Be Used in IDEs
=========================================

* Finding available refactorings
* A better facade
* Better refactoring categoriztion
* Making adding new refactorings easier


Decisions to Make
-----------------

* Unifying refactoring interfaces
* Introducing factories for refactorings;
  Reduce the dependence to `rope.refactor` modules


A Common Refactoring Interface
------------------------------

::

  class Refactoring(object):
      
      def __init__(self, *args, **kwds):
      """Getting immediate informations"""
      
      def get_changes(self, *args, **kwds):
      """Calculate the changes caused by this refactoring.
      
      It is passed user provided information.
      """
      
      # Other functions for getting information after construction
      # for helping IDE's.


Note that the arguments of `__init__` and `get_changes` are not the
same for all refactorings.


Finding Available Refactorings
------------------------------

The question we need to answer before proceeding is to decide
whether this belongs to UI or core.


Making Adding New Refactorings Easier
-------------------------------------

Adding a new refactoring requires changing `Refactoring` facade and
Adding the new refactoring class.  Duplications:

* Duplicate parameters
* We have the same refactoring class for inlines, extracts and
  renames but we have to call their constructors separately.


Moving Fields/Methods
=====================

* How tell that a pyname is a class attribute?

  * An attribute should be defined in a class or a method in a class
  * The holding class for a pyname should consider it as one of its
    attributes

* Moving defined objects

  * If self is used renaming it and passing it as a second argument?
  * Moving used imports

Move refactoring should support moving:

=======================  =============
source                   destination
=======================  =============
module                   module
global class/function    module
class fields/methods     attribute
static functions         class
=======================  =============

The problem of destination might be solved by passing a `PyName`
or a `PyObject` instead of a `Resource`.  Maybe we can take a
class as the destination for moving fields and methods instead
of an attribute.

Maybe we can have separate methods for moving each of above
groups.::
  
  move_module(resource, resource)
  move_global(pyobject, resource)
  move_attribute(pyobject, pyobject)


Dyanmic Type Inference Issues
=============================


Rejecting Smalltalk `RefactoringBrowser` Approach
-------------------------------------------------

We can't use smalltalks approach because it requires the whole
tests suite to be run before each refactoring but this does not
seem appealing because it might take a lot of time.

Apart from that if we use a wrapper for a function using python
runtime mechanisms it is possible to find out from which line
a function is called, but we cannot always find the offset in that
file from which this function is called.

If we solve these problems we can can use a strategy for finding
occurrences.  Also Think of other ways of collecting type information.


Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and dicts.


Python's Implicit Interfaces
============================

In python you don't have to define interfaces to declare that classes
use a specific protocol or interface.  There are lots of such examples
in standard library.

For example::
  
  class A(object):
      
      def a_method(self):
          pass
  
  class B(object):
      
      def a_method(self):
          pass
    
  def a_func(arg):
      arg.a_method()
  
  a_func(A())
  a_func(B())

Here although there is no inheritance relations between `A` and `B`,
renaming `A.a_method` should force `B.a_method` to be renamed too.

Or as another example::
  
  a_var = A()
  a_var.a_method()

renaming `a_var.a_method` should rename both `A.a_method` and
`B.a_method`.  That is `a_func` function defines the interface and its
members.

Now the problem is, if rope wants to support implicit interfaces, how
should it find out these interfaces and their members.


Not Supporting Implicit Interfaces
----------------------------------

If we plan not to support implicit interfaces things simplify
considerably.  Function arguments objects are the common base class
of encountered arguments and function returned value object is the
common base class of returned values.


Supporting Implicit Interfaces
------------------------------

We need to find out the way these implicit interfaces are defined.
Actually each function defines an interface for each of its parameters
and the members of this interface are the objects that are passed as
that arguement.  Another thing to keep in mind is that implicit
interfaces are extended by inheritance relation, too.  For example::
  
  class C(A):
      
      def a_method(self):
          pass
  
  def a_func(arg):
      arg.a_method()
  
  another_func(C())

Renaming `arg.a_method` not only should rename `C.a_method` but also it
it should rename `A.a_method`.

We should be careful about situations like::
  
  def a_func(arg):
      if isinstance(arg, A):
          arg.do_something()
      else:
          arg.do_some_other_thing()


Implementation Issues
---------------------

To support implicit interfaces we need to make lots of changes.  First
of all we know that a function parameter can be anything, so using DOI
we have a set of objects for each parameter.  So the question that
comes up here is when do we need parameter objects.

* When refactoring and finding occurrences
* When code assisting in a function

Also for a rename refactoring we need to check all functions and methods
for implicit interfaces that are involved.  This does not seem practical.
Find someway of making it possible.  Maybe we can find
all of the occurrences of a method and for each check whether it is
invoked on a parameter or not.  Now that we have a bigger set of
methods we need to do the same for these methods.  When we're finished
we can perform the actual refactoring.  The challenge here is that we
should consider inheritance relations, too.

Among `PyName` classes `AssignedName`, `ParameterName` and
`ImportedName` might have more than one object.  And I believe
the main place to change is `StatementEvaluator` that might
return a list of pynames in ``${attribute_accesses}.name``
where `attribute_accessses` might result in more than one kind
of pyname.  This implies that `get_pyname_at` might return a list
of pynames.

`objectinfer` should be changed to find all of the objects that can
be inferred.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary

After this refactoring, many places of rope can be refactored.  The
logical line is very useful in many places for instance.


The GUI Mess; Working More on the UI Parts
==========================================


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Not Resetting the Whole Editor
------------------------------

After actions like extract method, we reset the whole editor.  This is
slow and makes the undo difficult.  Find someway of solving this.  I
might be able to use `difflib` module.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?


Handling Multi-key Keyboard Shortcuts
-------------------------------------

Unfortunately `Tk` has problems for handling multi-key keyboard
shortcuts.  We can develop another independant keybinding system that
uses `Tk` to solve these problems.


A Good Keybinding
-----------------

Rope should have a good emacs-ish keybinding.

