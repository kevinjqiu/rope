=============
 Rope Issues
=============


Release Schedule
================

*rope* will be released every two weeks and each quarter a final
version would be released.  That is:

=======  ===============
Week #   Release Name
=======  ===============
2        x.ym1
4        x.ym2
6        x.ym3
8        x.ym4
10       x.ym5
12       x.ym6
13       x.y
=======  ===============

This is only a rough plan.  For example we might have 1-week release
candidates before the ``x.y``.


Version 0.6
===========

From May 7, 2007 till August 5, 2007


Release Goals
-------------

Metaphor: Supporting restructurings

Other Possible Goals:

* Finding similar pieces to extracted
* Formatting?


Hot Topics
==========

* `Restructuring UI`_
* `Revising extract module`_
* `Using _ast module`_


To Be Discussed
===============

* `Memory management`_
* `Better occurrence finding`_
* `Getting ready for Python 3.0`_
* `Python's implicit interfaces`_
* Decorators and method refactorings
* Should `rope.base` be thread safe? which parts?


Using _ast module
=================

Unfortunately the `compiler` package was removed for Python 3.  Rope
uses the `compiler` package extensively.  So I'm considering moving
to `_ast` module.  There are other reasons for doing so, too:

* `_ast` is much faster than `compiler`; since it's in C
* Some of the nodes in `_ast` have lineno and colno that make patching
  them easier or not needed at all.

Problems:

* `_ast` module is not available in Python 2.4.  So if we plan to use
  it we have to drop support for older versions of python.
* Lots of places use `compiler` package.  Changing all of those places
  needs lots of time.


Finding Similar Pieces
======================

Finally rope decided to start this story.  There are three main uses
for this feature.  One is finding similar code when extracting method/
variable.  The second is supporting restructurings.  And the third is
that it can be used to ease implementing some refactorings.

The main problem for implementing this story is that we need to work
on python ASTs and we need more information than what is provided by
`compiler` module.  For instance we need to find the start and end
offsets of nodes.  `rope.refactor.patchedast` has been implemented
to monkey patch ast nodes.

We should also decide about the way we define the pattern to search
for.  For now we can assume matching exactly what is passed but in
future that will probably change.  We probably need to insert pyobject
information in the searching pattern, too.


AST Patterns
------------

We need to put wild-cards into our pattern:

* ``${a}``: Match the name `a`
* ``${?a}``: Match any expression

What `similarfinder` does is that it matches these and holds the
matched AST for future use.  This allows to add a layer on top of it
that checks types, too.  For example we can add constraints as it is
shown in the next section.

Suggestions and issues:

* Where can wildcards appear?

  Although the names can appear in many places we limit that by
  forcing the wildcards to appear only where `Name` and `AssName` can
  appear.

* Efficiency:

  The `Node.sorted_children` field was added for saving formatting and
  easier testing.  But it not seem to be necessary in `similarfinder`
  module.  So maybe we can pass a `sorded_children` keyword to
  `patchedast.patchast` that controls whether to add this field or
  not.



Adding Name Checks
------------------

Now that we can match similar AST nodes, we can do our last move for
making the examples in `a look into the future`_ section real.  I
propose to add `CheckingFinder` class.

Possible accessors can be nothing for checking `PyName`\s, ``.object``
for checking `PyObject`\s (derived by calling ``pyname.get_object()``)
and ``.type`` for checking the type (derived by calling ``pyname.
get_object.get_type()``).

A question that comes up is why don't we add a ``match when unsure``
option.  This is different from something like rename refactoring.
Consider a situation like ``${a_var}.a_func()``.  In this example,
matching when unsure does not work::

  def f(arg):
      arg.a_func()

We expect ``arg.a_func()`` to match, but it does not since `args` is a
`Parameter` and `a_var` is a `PyName`.  So we know that they are not
the same pyname.  Note that when renaming we don't compare `arg` to
`arg` but instead we compare `a_func` that yields what we want.


A Look Into The Future
----------------------

This is no longer the future.  It can be done right now using
`rope.refactor.restructure` module.  But the current UI restructuring
dialog does not support checking names.

Restructuring::

  # ``a = b`` to ``a.set(b)`` where the type of `a` is `type_pyclass`
  pattern = '${?a} = ${?b}'
  goal = '${?a}.set(${?b})'
  checks = {'?a.type': type_pyclass}

  # ``a.set(b)`` to ``a = b`` where the type of `a` is `type_pyclass`
  pattern = '${?a}.set(${?b})'
  goal = '${?a} = ${?b}'
  checks = {'?a.type': type_pyclass}

  # Rematching might be useful, too
  pattern = '${?x} = [${?a}, ${?a}]'
  goal = '${?x} = [${?a}] * 2'


Restructuring UI
================

If restructuring is going to be used by a normal python user it has to
have a good UI.  The search pattern and the goal is straightforward
but adding checks is the real problem.

We can have a list of changes.  Each item in this list is a tuple
containing whose first item is a name that appear in search pattern
plus an identifier like '', '.object', '.type'.  Its second item should
be a string that indicates a `PyName` or a `PyObject`.

Now the we have to find good ways for:

* Specifying a `PyName` or `PyObject`
* Differentiating between `PyName`\s and `PyObject`\s


Patched AST
===========

I propose to construct a patched AST from code that holds formatting
info.

Supporting Formatting
---------------------

We can handle formatting as we are patching the old AST.  Instead of
using the text formatting data we can insert the formatting specific
data.


Handling Changed ASTs
---------------------

Restructurings need to replace an AST node with another AST node.  We
can do this by searching over the parents nodes and `sorted_children`.
Whenever we encounter the old AST node we replace it with the new one.

There are two approaches here.

* We can change ASTs to construct a new AST
* We can derived change source from the main AST

The second approach seems more practical.  We can have a class that
takes a `similarfinder.Match` object and a goal pattern.  The
placeholders in the goal pattern will be replaced with the matched
ASTs in the match object and written back inplace of the original
occurrence.


Revising `extract` Module
=========================

Now that we've developed `similarfinder` module, we can change extract
refactoring to use this new module.  The algorithm is like this:

* Compile the extracted code and search for that AST in holding scopes.
* Find a good place for inserting the definition based on the matches.
* Replace each occurrence with extracted and add definition.

But there are lots of special cases for performing extract
refactoring.  For example the insertion point for a variable or a
global function is the line before the first occurrence while the
insertion point for methods is right after the holding method.

What's more currently `similarfinder` does not support patterns.  That
is necessary for extract method refactoring.


Memory Management
=================

These are the places in which rope spends most of the memory it
consumes:

* PyCore: for storing PyModules
* ObjectInfo: for storing object information
* History: for storing changes

We should measure the amount of memory each of them uses to make
decisions.


Better SOI
==========

Returned Object SOI
-------------------

Since we're passed the objects parameters hold, we can perform a
better returned object SOI.  We can do that by giving parameter
objects passed and infer the object of local names once more.

Actually we have to perform two things.  We have to ask scope
`PyName`\s to forget their concluded data and change the parameters to
return what we want.

So to make it we have:

* Used `PyFunction._set_parameter_pyobjects()` to set the type
  of parameters
* Added `FunctionScope.invalidate_data()` to invalidate the
  pyobjects `AssignedName`\s and `EvaluatedName`\s hold.

And after implementing these we thought of treating function scopes
specially, since the names there cannot be accessed from outside.


Function Scopes
---------------

Another issue for implementing this feature is that function scope
variable types are dependent on the type of the parameters and should
change.  This issue seem to have some relations with implicit
interfaces.

These two problems(in the above section) points us to treating
function scopes specially.  Since function names are not accessible
from outside that function, we can perform all calculations in a
temporary place.

The problem gets worse when there are defined objects in a function
scope.  Maybe we can change pynames to support function scopes.


Enhancing `ObjectInfoManager`
=============================

* Changing `callinfo` to match similar args
* Some `self`\s are unknown!
* Returning a `Generator` for unknown generator functions?
* Validating call infos


Better Concluded Data
=====================

The main problem is when using star imports, after a module has been
invalidated its concluded data still exist.  This does not seem to be
a major memory leak, since these `_ConcludedData`\s are invalidated
and contain `None`.

* Using weak references for holding concluded data
* Changing `ImportedName` not to store the imported object in a
  concluded data.  This might slow things a bit.
* Changing `StarImport` to use a mock concluded data for its
  `ImportedModule` and `ImportedName`\s

The other suggestion here is that currently `ImportedName`\s store
object information in the concluded data of the importing module while
they can get concluded data from imported module.  The problem happens
when the imported module gets deleted.

Note that concluded attributes are:

* PyClass: superclass attributes
* PyModule: star imports
* PyPackage: ``__init__.py`` attributes


Marking Errors And Warnings In GUI
==================================

* Marking the occurrence in the buffer
* When to analyze the code?

  * When the user asks
  * When saving

* Saving error/warning information
* ``C-,``, ``C-.``
* ``C-c a p``, ``C-c a n``


Better Occurrence Finding
=========================

The current implementation for finding occurrences of a `PyName` is to
test every textual occurrence of that name has the same `PyName` or
not.  This approach does not work when a name is repeated many times
in the source.  For example renaming `self`\s are very time consuming.

Maybe we can use one of these solutions:

* Checking pyname equality only once for each scope

  This way we check each name only once for each scope.  But this is
  not applicable for attributes.  What's more `PyName`\s seem to
  cache their types already.

* Limiting the places to search for a name

  For example for renaming a parameter we search the body of that
  function and the keyword arguments passed to functions.  As another
  example function parameters never appear as attributes and class
  variables and methods never are referenced directly except in class
  body.  The search locations include:

  * module bodies
  * class bodies
  * function bodies

  Access methods include:

  * function call keyword
  * normal name access
  * attribute access

* Excluding unimported modules

  This does not seem to be a good solution.  One reason is that the
  imports might be indirect.  So we have to put a long time for
  creating import trees.

Or maybe we can use a strategy object for searching.


Getting Ready For Python 3.0
============================

Unfortunately it seems impossible to make rope both a valid Python 2.x
and 3.x program.  Possible approaches are having two separate branches
of rope (that I strongly resist) or moving from 2.x to 3.x gradually.

We can also maintain rope so that it can be used for writing python
3.x programs as well as 2.x while running on 2.x.  The main problem is
the `compiler` package.  After that when we finally drop support for
running rope on 2.x and it would need 3.x to run.  But it can be used
to write 2.x programs as well as 3.x.

* Updating `rope.refactor.patchedast` module for using new nodes
* Updating `rope.base.evaluate`
* Updating `rope.base.builtins`
* Changing `rope.refactor.funcutils` to handle keyword only args
* Changing print to function in tests
* Not supporting old relative imports
* `iter.__next__()` instead of `iter.next()`?
* Supporting `bytes`, `input`
* Removing nonexistent dict methods and methods that will return sets
* Chaning imports after library reorganization
* Show function annotations in pydocs
* ``nonlocal``
* ``except xxx as yyy``
* Supporting keyword only arguments
* Set literals and comprehension ``{1, 2, 3}`` and ``{x for x in range(10)}``
* Renamed function attributes; ``f.func_whatever`` to ``f.__whatever__``
* Use new function signature
* Not using ``__cmp__``
* Updating integer and string literal patterns


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In futures some of this restrictions might be removed.

* All files that end with ``.py`` are considered to be python files and
  all others not.
* Either all files that are not ignored should be under version
  control or none.
* All ``*.txt`` files are considered in reST formats.
* XXX


Object Inference Issues
=======================


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself, too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed we should make some difference between the objects that we
only care about their types and the objects that their individual
instance is important to us.  Right now the latter group contains
only functions, classes, modules, lists, dicts and sets but this
list will be probably extended.


Python's Implicit Interfaces
============================

Basic Implicit Interfaces
-------------------------

There are many dark points about these interfaces, but we should start
from somewhere.


Overview
--------

In python you don't have to define interfaces to declare that classes
use a specific protocol or interface.  There are lots of such examples
in standard library.

For example::

  class A(object):

      def a_method(self):
          pass

  class B(object):

      def a_method(self):
          pass

  def a_func(arg):
      arg.a_method()

  a_func(A())
  a_func(B())

Here although there is no inheritance relations between `A` and `B`,
renaming `A.a_method` should force `B.a_method` to be renamed too.

Or as another example::

  a_var = A()
  a_var.a_method()

renaming `a_var.a_method` should rename both `A.a_method` and
`B.a_method`.  That is `a_func` function defines the interface and its
members.

Now the problem is, if rope wants to support implicit interfaces, how
should it find out these interfaces and their members.


Supporting Implicit Interfaces
------------------------------

We need to find out the way these implicit interfaces are defined.
Actually each function defines an interface for each of its parameters
and the members of this interface are the objects that are passed as
that argument.  Another thing to keep in mind is that implicit
interfaces are extended by inheritance relation, too.  For example::

  class C(A):

      def a_method(self):
          pass

  def a_func(arg):
      arg.a_method()

  another_func(C())

Renaming `arg.a_method` not only should rename `C.a_method` but also
it should rename `A.a_method`.

We should be careful about situations like::

  def a_func(arg):
      if isinstance(arg, A):
          arg.do_something()
      else:
          arg.do_some_other_thing()

The other issue is what to do for situations like this::

  def a_func(obj1, obj2):
      result = obj1.f(obj2)
      result.g()

The problem is we don't know the types of `obj1` and `obj2` exactly
and we have a list of types that these variables are assigned during
program execution.  `obj1.f` is not a specific method.


The GUI Mess; Working More on the UI Parts
==========================================


Version Control Commands
------------------------

* Commit; ``C-x v c``
* Update; ``C-x v u``
* Diff; ``C-x v d``
* Log; ``C-x v l``
* Revert; ``C-x v r``
* Remove; ``C-x v v``
* Status; ``C-x v s``
* Add; ``C-x v a``
* Blame; ``C-x v b``


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?
