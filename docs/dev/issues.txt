=============
 Rope Issues
=============


Release Schedule
================

*rope* will be released every two weeks and each quarter a final
version would be released.  That is:

=======  ===============
Week #   Release Number
=======  ===============
2        x.ym1
4        x.ym2
6        x.ym3
8        x.ym4
10       x.ym5
12       x.yrc1
13       x.y
=======  ===============

This is only a rough plan.  For example we might have more release
candidates before the ``x.y`` release.


Version 0.4
===========

From November 6, 2006 till February 4, 2007


Release Goals
-------------

Metaphor: Enhance features and make rope extensible


Release Goals
-------------

* Rope library


Possible Plans
--------------

* Inline method
* Change method signature
* Introduce parameter
* Enhancing refactorings and testing
* Move field/methods

Exploring and analyzing possible solutions for:

* Handling built-in types
* Implicit interfaces


Status
------

Now that rope supports many basic refactorings it seems necessary to
put more time on enhancing old refactorings and finishing remaining
stories.  So from till ``0.4`` we will:

* Enhance old refactorings
* Do remaining stories
* Test
* Explore better OI; supporting builtins and implicit interfaces


Hot Topics
==========

* `Having Virtual PyModules`_
* `Library Movement`_


To Be Discussed
===============

* `Python's Implicit Interfaces`_
* Removing `PythonRefactoring` facade
* Rope's preference saving system: format, location
* Indexing source files for faster occurrence finding
* Having a persistant format for PyNames and PyObjects for saving
  hard to compute information like class hierarchies
* Using a modification of `compiler` AST for simplifying refactorings
* Undo Unification


Refactoring Import Utils
========================

The special thing about `importutils` module is that it is used by
other refactorings on an already changed module.  Most of the time
its methods return the changed source code of a module.


Having Virtual `PyModule`\s
===========================

What Do We Gain?
----------------

After this refactoring we'll be able to mix any of the refactorings
and move toward bigger refactorings.

* Handling import changes for all modules

  One of the problems we are facing when performing refactorings is
  that imports need to be changed in some of the modules involved in
  that refactoring, but since those modules are already changed for
  that refactoring, it cannot be changed once more easily.

* Performing multiple refactorings in sequence

  For example for performing move method refactoring we can rename the
  self parameter of the method and then move the method itself.  Then
  move the imports used.

* Support for bigger refactorings

  Examples:


Consequences
------------

* Complexity of implementation

  After a change the internal representation of project should be
  updated.  This requires for example changes to
  `Folder.get_children` and `File.read`.

* Inefficiency because of multiple changes while refactoring

  If in a refactoring we perform ``3`` changes we might also need to
  recompute the information calculated in some of the `PyModule`\s
  ``3`` times.  This seems inefficient.

* Inefficiency due to missing computed information computed locally

  One of the difficulties of having a set of main and many local
  `PyModule`\s is that when we compute some information in local
  ones this information might be no longer valid in global pymodules.
  

* Not convincing uses

  Right know the only need for performing multiple refactorings is
  for changing imports after performing a refactoring and it has been
  handled using some kind of virtual `PyModule` already.  We could
  not think of any good refactoring that needs to perform multiple
  basic refactorings.

* Lots of changes
  
  This refactoring needs lots of changes to `PyCore` and modules that
  use it.  Some of these changes need to change the design very much.

* Complex design

  Managing multiple `PyCore`\s and changing `PyObject`\s to work with
  many of them at the same time seems to be hard.


A Bit in Details
----------------

If we change all refactoring modules to work on a pymodule we would
probably be able to have a structure like this::
  
  class PythonProjectFiles(object):
      
      def resource_to_pyobject(self, resource):
          pass
      
      def get_module(self, module_name):
          pass
  
  
  class ChangedPythonProjectFiles(PythonProjectFiles):
      
      def resource_to_pyobject(self, resource):
          pass
      
      def get_module(self, module_name):
          pass
      
      def file_changed(self, resource, new_content):
          pass
      
      def move_resource(self, resource, new_location):
          pass

      def get_changes(self):
          pass
          

This way we can perform any number of refactorings in sequence.  But
it seems as if we should break `PyCore` into two separate classes.
What's more after this change we would probably be able to remove
`rope.refactor.change`.  Maybe we can add `Change...` interfaces to 
`ChangedPythonProjectFiles`.

One of the main obstacles for doing this change is that all of the
`PyObjects` have a reference to the `PyCore` and ask them about
other modules.  This causes problems because we want all of the
`PyObjects` to use a local `PyCore`.

What's more computed information might be valid in a local scope
but might be invalid in the rest of project.


Preventing Unnecessary Recomputations
-------------------------------------

* Using copy on write
* Updating global `PyCore` after performing changes


Gradual Implementation
----------------------

Since this would be a big refactoring we need to divide this
refactoring into a few smaller tasks.


Simple Implementation
---------------------

A simple implementation would be possible by using plain and new
`PythonProjectFiles` from the beginning.  But the performance might
really hurt if we actually use it but it won't change if we don't.
So actually it is a extract class refactorings.


Updating Changed Files
======================

:Motives:
  * Forcing rope to update its files when using rope as a library
  * Moving folders should not be performed recursively (for VCS's)
:Goals:
  * Adding `Project.validate`
  * Holding last changed time for files

Todo:

* Using last changed time in `Project.validate`
* Preventing multiple observer calls for the same resource

Decisions to make:

* Set of changes

  * Calling observers only once after a set of related changes
  * Change transactions for `ChangeSet`\s
  * Merging `resource_removed`\s


Inline Method
=============

* Which of the variables should be renamed?
* What to do about parameter assignments?
* What to do about staticmethod an classmethods decorators
* Moving used imports and importing defining module globals
* Inlining generators
* Inner functions


Library Movement
================

* Adding `read` and `write` to `rope.base.fscommands`?


Using ASTs For Transformations
==============================

The main problem with AST nodes is that they only hold the line in
which statements appear but we need the offset.  If we add offset
information to AST nodes, we would be able to use them for all of the
tasks that we do right now using direct operations on program source
code.

Using ASTs for transforming programs requires making a new AST tree
or altering the old one and writing AST trees.  We can use the latter
in the formatter, too but it seems a lot of work.


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In futures some of this restrictions might be removed.

* All of the modules should use 4 spaces for indenting and no hard tabs.
* All files that end with ``.py`` are considered to be python files and
  all others not.
* Either all files should be under version control or none.
* All ``*.txt`` files are considered in reST formats.
* XXX


Designing Refactorings to Be Used in IDEs
=========================================

* Finding available refactorings
* A better facade
* Better refactoring categoriztion
* Making adding new refactorings easier


Decisions to Make
-----------------

* Unifying refactoring interfaces
* Introducing factories for refactorings;
  Reduce the dependence to `rope.refactor` modules
* Removing `rope.refactor.PythonRefactoring`


A Common Refactoring Interface
------------------------------

::

  class Refactoring(object):
      
      def __init__(self, *args, **kwds):
      """Getting immediate informations"""
      
      def get_changes(self, *args, **kwds):
      """Calculate the changes caused by this refactoring.
      
      It is passed user provided information.
      """
      
      # Other functions for getting information after construction
      # for helping IDE's.


Note that the arguments of `__init__` and `get_changes` are not the
same for all refactorings.


Finding Available Refactorings
------------------------------

The question we need to answer before proceeding is to decide
whether this belongs to UI or core.


Making Adding New Refactorings Easier
-------------------------------------

Adding a new refactoring requires changing `Refactoring` facade and
Adding the new refactoring class.  Duplications:

* Duplicate parameters
* We have the same refactoring class for inlines, extracts and
  renames but we have to call their constructors separately.


Moving Fields/Methods
=====================

* How tell that a pyname is a class attribute?

  * An attribute should be defined in a class or a method in a class
  * The holding class for a pyname should consider it as one of its
    attributes

* Moving defined objects

  * If self is used renaming it and passing it as a second argument?
  * Moving used imports

Move refactoring should support moving:

=======================  =============
source                   destination
=======================  =============
module                   module
global class/function    module
class fields/methods     attribute
static functions         class
=======================  =============

The problem of destination might be solved by passing a `PyName`
or a `PyObject` instead of a `Resource`.  Maybe we can take a
class as the destination for moving fields and methods instead
of an attribute.

Maybe we can have separate methods for moving each of above
groups.::
  
  move_module(resource, resource)
  move_global(pyobject, resource)
  move_attribute(pyobject, pyobject)


Object Inference Issues
=======================


Better Object Inference
-----------------------

Currently rope's object inference mechanisms are simple and there are
many situations that they are of no use:

* A simple dynamic type inference saves the return types of methods
* We use a simple static type inference that:
  
  * Follows assignments
  * Checks the returned ASTs
  * Uses method return value and parameter information gained by DOI

We are very interested in supporting:

* Builtin types
* Implicit interfaces

Possible alternatives:

* Saving the type of local variables when exiting a scope
* Having a set of functions to record the place they are called
* Having a flag that lets us save information per instance
* Saving the result of every call
* Using static type inference algorithms


Supporting Built-in Types
-------------------------

The main motive for supporting built-in types are `list`, `dict` and
`set`.  We try to start with the simplest of these; `list` types.


Supporting `list`
`````````````````

It is relatively easy to support `list` as being a type with some
functions, but the main motive for supporting `list`\s is providing
meaningful return values from its functions such as `__index__` or
providing correct variables in for loops.  To do these we assume that
every list only contains one type of objects.

* How should we infer the type an iterator holds?

One way of doing this is object inference of `list.append` or other
insertion functions.  But the difficulty here is we should infer
the parameters of these functions for each instance in program source
rather than for the list type in whole.  This analysis should be
performed at runtime.

* `ObjectInfer.infer_holding_type` for `iterator`\s
* Addition of a flag to types that indicates the distinction of
  instances.
* Can we support `iterator` types, too?


Rejecting Smalltalk `RefactoringBrowser` Approach
-------------------------------------------------

We can't use smalltalks approach because it requires the whole
tests suite to be run before each refactoring and this does not
seem appealing because it might take a lot of time.

Apart from that if we use a wrapper for a function using python
runtime mechanisms it is possible to find out from which line
a function is called, but we cannot always find the offset in that
file from which this function is called.

If we solve these problems we can can use a strategy for finding
occurrences.  Also Think of other ways of collecting type information.


Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and dicts.


Python's Implicit Interfaces
============================

In python you don't have to define interfaces to declare that classes
use a specific protocol or interface.  There are lots of such examples
in standard library.

For example::
  
  class A(object):
      
      def a_method(self):
          pass
  
  class B(object):
      
      def a_method(self):
          pass
    
  def a_func(arg):
      arg.a_method()
  
  a_func(A())
  a_func(B())

Here although there is no inheritance relations between `A` and `B`,
renaming `A.a_method` should force `B.a_method` to be renamed too.

Or as another example::
  
  a_var = A()
  a_var.a_method()

renaming `a_var.a_method` should rename both `A.a_method` and
`B.a_method`.  That is `a_func` function defines the interface and its
members.

Now the problem is, if rope wants to support implicit interfaces, how
should it find out these interfaces and their members.


Not Supporting Implicit Interfaces
----------------------------------

If we plan not to support implicit interfaces things simplify
considerably.  Function arguments objects are the common base class
of encountered arguments and function returned value object is the
common base class of returned values.


Supporting Implicit Interfaces
------------------------------

We need to find out the way these implicit interfaces are defined.
Actually each function defines an interface for each of its parameters
and the members of this interface are the objects that are passed as
that arguement.  Another thing to keep in mind is that implicit
interfaces are extended by inheritance relation, too.  For example::
  
  class C(A):
      
      def a_method(self):
          pass
  
  def a_func(arg):
      arg.a_method()
  
  another_func(C())

Renaming `arg.a_method` not only should rename `C.a_method` but also it
it should rename `A.a_method`.

We should be careful about situations like::
  
  def a_func(arg):
      if isinstance(arg, A):
          arg.do_something()
      else:
          arg.do_some_other_thing()

The other issue is what to do for situations like this::
  
  def a_func(obj1, obj2):
      result = obj1.f(obj2)
      result.g()

The problem is we don't know the types of `obj1` and `obj2` exactly
and we have a list of types that these variables are assigned during
program execution.  `obj1.f` is not a specific method.


Implementation Issues
---------------------

To support implicit interfaces we need to make lots of changes.  First
of all we know that a function parameter can be anything, so using DOI
we have a set of objects for each parameter.  So the question that
comes up here is when do we need parameter objects.

* When refactoring and finding occurrences
* When code assisting in a function

Also for a rename refactoring we need to check all functions and methods
for implicit interfaces that are involved.  This does not seem practical.
Find someway of making it possible.  Maybe we can find
all of the occurrences of a method and for each check whether it is
invoked on a parameter or not.  Now that we have a bigger set of
methods we need to do the same for these methods.  When we're finished
we can perform the actual refactoring.  The challenge here is that we
should consider inheritance relations, too.

Among `PyName` classes `AssignedName`, `ParameterName` and
`ImportedName` might have more than one object.  And I believe
the main place to change is `StatementEvaluator` that might
return a list of pynames in ``${attribute_accesses}.name``
where `attribute_accessses` might result in more than one kind
of pyname.  This implies that `get_pyname_at` might return a list
of pynames.

`objectinfer` should be changed to find all of the objects that can
be inferred.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary

After this refactoring, many places of rope can be refactored.  The
logical line is very useful in many places for instance.


The GUI Mess; Working More on the UI Parts
==========================================


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Not Resetting the Whole Editor
------------------------------

After actions like extract method, we reset the whole editor.  This is
slow and makes the undo difficult.  Find someway of solving this.  I
might be able to use `difflib` module.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?


Handling Multi-key Keyboard Shortcuts
-------------------------------------

Unfortunately `Tk` has problems for handling multi-key keyboard
shortcuts.  We can develop another independant keybinding system that
uses `Tk` to solve these problems.


A Good Keybinding
-----------------

Rope should have a good emacs-ish keybinding.
