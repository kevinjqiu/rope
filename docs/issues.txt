=============
 Rope Issues
=============


Release Schedule
================

*rope* will be release every two weeks and one final release every
quarter.  That is

=====  ===============
Week   Release Number
=====  ===============
2      x.ym1
4      x.ym2
6      x.ym3
8      x.ym4
10     x.ym5
12     x.yrc1
13     x.y
=====  ===============

This is only a rough plan.  For example some more release candidates
might be released before the ``x.y`` release.


Version 0.3
===========

From August 7, 2006 till November 5, 2006


Release Goals
-------------

Metaphor: Deliver the most interesting features


Releases
--------

0.3m1
    Done.
0.3m2
    Done.
0.3m3
    Done.
0.3m4
    Done.
0.3m5
    Done.
0.3rc1
    Working one.


Hot Topics
==========

* `Undo Unification`_
* `Python's Implicit Interfaces`_


To Be Discussed
===============

* Rope's preference saving system: format, location
* Having a persistant format for PyNames and PyObjects for saving
  hard to compute information like class hierarchies
* Using a modification of `compiler` AST for simplifying refactorings
* Indexing source files for faster occurrence finding


Undo Unification
================

Currently there are separate undo actions for editing text and
refactorings and in future there might be undos for other changes.  We
need to mix them together.  This seems hard to do mainly because we
don't have much access to the undo mechanism of Tkinter.  I think an
approximation here will save us.


Adding SVN Support Using `pysvn`
================================

Currently `rope.fscommands` module makes an all or nothing assumption.
Either all or none of the files should be under version control.

We should be able to make transaction so that if an error occurs
during one action we can revert back.


Moving Fields/Methods
=====================

* How tell that a pyname is a class attribute?

  * An attribute should be defined in a class or a method in a class
  * The holding class for a pyname should consider it as one of its
    attributes

* Moving defined objects

  * If self is used renaming it and passing it as a second argument?
  * Moving used imports

Move refactoring should support moving:

=======================  =============
source                   destination
=======================  =============
module                   module
global class/function    module
class fields/methods     attribute
static functions         class
=======================  =============

The problem of destination might be solved by passing a `PyName`
or a `PyObject` instead of a `Resource`.  Maybe we can take a
class as the destination for moving fields and methods instead
of an attribute.

Maybe we can have separate methods for moving each of above
groups.::
  
  move_module(resource, resource)
  move_global(pyobject, resource)
  move_attribute(pyobject, pyobject)


Renaming And Occurrence Finding
==============================

What is the responsibility of `OccurrenceFinder`.  Should it only
find text occurrences or should it also do some filtering and check
for `PyName` equality?

The problem is we want to be able to replace occurrences with
different strings, depending on the kind of access.

Maybe what we need is a rename interface::
  
  class OccurrenceFinder(object):
      
      def find_occurrences(self, ...):
          """Generates `Occurrence` instances"""
  
  class Occurrence(object):
      
      def get_word_range(self):
          pass
      
      def get_primary_range(self):
          pass
      
      def get_pyname(self, pyname_finder):
          pass
      
      def is_in_import_statement(self):
          pass
      
      def is_called(self):
          pass
      
      def is_read(self):
          pass
      
      def is_written(self):
          pass
  
  class FilteredOccurrenceFinder(object):
      
      def __init__(self, ..., pyname, imports, calls):
          pass
  
      def find_occurrences(self, ...):
          pass
  
  class GenericRename(object):
      
      def __init__(self, ..., occurrence_finder):
          pass
  
  done.

This new approach makes easy for writing a new Rename class that
only replaces what it wants.


Dyanmic Type Inference Issues
=============================

Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and dicts.


Python's Implicit Interfaces
============================

In python you don't have to define interfaces to declare that classes
use a specific protocol or interface.  There are lots of such examples
in standard library.

For example::
  
  class A(object):
      
      def a_method(self):
          pass
  
  class B(object):
      
      def a_method(self):
          pass
    
  def a_func(arg):
      arg.a_method()
  
  a_func(A())
  a_func(B())

Here although there is no inheritance relations between `A` and `B`,
renaming `A.a_method` should force `B.a_method` to be renamed too.

Or as another example::
  
  a_var = A()
  a_var.a_method()

renaming `a_var.a_method` should rename both `A.a_method` and
`B.a_method`.  That is `a_func` function defines the interface and its
members.

Now the problem is, if rope wants to support implicit interfaces, how
should it find out these interfaces and their members.


Not Supporting Implicit Interfaces
----------------------------------

If we plan not to support implicit interfaces things simplify
considerably.  Function arguments objects are the common base class
of encountered arguments and function returned value object is the
common base class of returned values.


Supporting Implicit Interfaces
------------------------------

We need to find out the way these implicit interfaces are defined.
Actually each function defines an interface for each of its parameters
and the members of this interface are the objects that are passed as
that arguement.  Another thing to keep in mind is that implicit
interfaces are extended by inheritance relation, too.  For example::
  
  class C(A):
      
      def a_method(self):
          pass
  
  def a_func(arg):
      arg.a_method()
  
  another_func(C())

Renaming `arg.a_method` not only should rename `C.a_method` but also it
it should rename `A.a_method`.

We should be careful about situations like::
  
  def a_func(arg):
      if isinstance(arg, A):
          arg.do_something()
      else:
          arg.do_some_other_thing()


Implementation Issues
---------------------

To support implicit interfaces we need to make lots of changes.  First
of all we know that a function parameter can be anything, so using DOI
we have a set of objects for each parameter.  So the question that
comes up here is when do we need parameter objects.

* When refactoring and finding occurrences
* When code assisting in a function

Also for a rename refactoring we need to check all functions and methods
for implicit interfaces that are involved.  This does not seem practical.
Find someway of making it possible.  Maybe we can find
all of the occurrences of a method and for each check whether it is
invoked on a parameter or not.  Now that we have a bigger set of
methods we need to do the same for these methods.  When we're finished
we can perform the actual refactoring.  The challenge here is that we
should consider inheritance relations, too.

Among `PyName` classes `AssignedName`, `ParameterName` and
`ImportedName` might have more than one object.  And I believe
the main place to change is `StatementEvaluator` that might
return a list of pynames in ``${attribute_accesses}.name``
where `attribute_accessses` might result in more than one kind
of pyname.  This implies that `get_pyname_at` might return a list
of pynames.

`objectinfer` should be changed to find all of the objects that can
be inferred.


Which Is Right? Type Or Object Inference
========================================

Should we use type inference or object inference? I believe object
inference is better.  What we try do is to infer the object a variable
references during program execution.  Sometimes we are only interested
in the type of the referenced object and sometimes we need the object
itself.  This latter situation occurs when an instance holds
interesting information that does not exist in its type.

As an example classes(types) are instances of `type` class.  That is
their type is `type`.  But knowing their type does not give us much
information about the methods defined in these derived classes.


Builtin Types And Functions
===========================

What should we do about builtin functions and types?

Builtin types:

* list, typle
* dict
* str, unicode
* file
* set, frozenset
* int, float, long, complex
* iterator types
* boolean

Builtin constants:

* False
* True
* None
* NotImplemented
* Ellipsis

Builtin functions:

* range
* super

One approach to builtin types would be to use the `__builtin__` module
dynamically.  The other might be to write classes for the most
interesting ones like `list`\s, `dict`\s and `str`\s.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary

After this refactoring, many places of rope can be refactored.  The
logical line is very useful in many places for instance.


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In futures some of this restrictions might be removed.

* All of the modules should use 4 spaces for indenting and no hard tabs.
* All files that end with ``.py`` are considered to be python files and
  all others not.
* Either all files should be under version control or none.
* All ``*.txt`` files are considered in reST formats.
* XXX


The GUI Mess; Working More on the UI Parts
==========================================


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Not Resetting the Whole Editor
------------------------------

After actions like extract method, we reset the whole editor.  This is
slow and makes the undo difficult.  Find someway of solving this.  I
might be able to use `difflib` module.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?


Handling Multi-key Keyboard Shortcuts
-------------------------------------

Unfortunately `Tk` has problems for handling multi-key keyboard
shortcuts.  We can develop another independant keybinding system that
uses `Tk` to solve these problems.


A Good Keybinding
-----------------

Make a good emacs-ish keybinding.
