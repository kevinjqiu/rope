=============
 Rope Issues
=============


Release Schedule
================

*rope* will be release every two weeks and one final release every
quarter.  That is

=====  ===============
Week   Release Number
=====  ===============
2      x.ym1
4      x.ym2
6      x.ym3
8      x.ym4
10     x.ym5
12     x.yrc1
13     x.y
=====  ===============

This is only a rough plan.  For example some more release candidates
might be released before the ``x.y`` release.


Version 0.3
===========

From August 7, 2006 till November 5, 2006


Release Goals
-------------

Metaphor: Deliver the most interesting features


Releases
--------

0.3m1
    Done.
0.3m2
    Done.
0.3m3
    Done.
0.3m4
    Done.
0.3m5
    Done.
0.3rc1
    Done.


Possible Plans For 0.4
======================

* Inline method
* Move field/methods
* Change method signature
* Implicit interfaces
* Handling built-in types


Hot Topics
==========

* `Undo Unification`_
* `Python's Implicit Interfaces`_


To Be Discussed
===============

* Designing refactorings to be used in IDEs
* Rope's preference saving system: format, location

* Indexing source files for faster occurrence finding
* Having a persistant format for PyNames and PyObjects for saving
  hard to compute information like class hierarchies
* Using a modification of `compiler` AST for simplifying refactorings


Designing Refactorings to Be Used in IDEs
=========================================

* Multi-step refactorings
* Previewing refactorings
* Finding available refactorings
* A better facade
* Better refactoring categoriztion
* Making adding new refactorings easier


Decisions to Make
-----------------

* Unifying refactoring interfaces
* Introducing factories for refactorings;
  Reduce the dependence to `rope.refactor` modules


Multi-step Refactorings
-----------------------

A refactoring should be done in three steps.

1. Getting immediate information
   
   After this step we can provide some useful information.  Like the
   initial name for rename refactoring.
   
2. Getting user provided information

   The problem with this step is that based on the first step we
   might need different data.  For example for move refactoring we
   need different information for moving a field versus moving a
   class.
   
   This separation helps us to report some of the errors earlier.

3. Finding the changes to be made

   We perform the actual refactoring here.  After this step we can
   preview the changes.

4. Performing the refactoring


What will happen to `PythonRefactoring` facade?


A Common Refactoring Interface
------------------------------

::
  class Refactoring(object):
      
      def __init__(self, *args, **kwds):
      """Getting immediate informations"""
      
      def get_changes(self, *args, **kwds):
      """Calculate the changes caused by this refactoring.
      
      It is passed user provided information.
      """
      
      # Other functions for getting information after construction
      # for helping IDE's.


Note that the arguments of `__init__` and `get_changes` are not the
same for all refactorings.


Finding Available Refactorings
------------------------------

The question we need to answer before proceeding is to decide
whether this belongs to UI or core.


Undo Unification
================

Currently there are separate undo actions for editing text and
refactorings and in future there might be undos for other changes.  We
need to mix them together.  This seems hard to do mainly because we
don't have much access to the undo mechanism of Tkinter.  I think an
approximation here will save us.


Moving Fields/Methods
=====================

* How tell that a pyname is a class attribute?

  * An attribute should be defined in a class or a method in a class
  * The holding class for a pyname should consider it as one of its
    attributes

* Moving defined objects

  * If self is used renaming it and passing it as a second argument?
  * Moving used imports

Move refactoring should support moving:

=======================  =============
source                   destination
=======================  =============
module                   module
global class/function    module
class fields/methods     attribute
static functions         class
=======================  =============

The problem of destination might be solved by passing a `PyName`
or a `PyObject` instead of a `Resource`.  Maybe we can take a
class as the destination for moving fields and methods instead
of an attribute.

Maybe we can have separate methods for moving each of above
groups.::
  
  move_module(resource, resource)
  move_global(pyobject, resource)
  move_attribute(pyobject, pyobject)


Dyanmic Type Inference Issues
=============================


Rejecting Smalltalk `RefactoringBrowser` Approach
-------------------------------------------------

We can't use smalltalks approach because it requires the whole
tests suite to be run before each refactoring but this does not
seem appealing because it takes time and considering the added
time of tracing each function call it takes even more.

But I think the same problem existed in smalltalk, too.  Look what
they did to overcome this problem.  You can also use a strategy
for testing this approach for finding occurances.  Maybe in future
when CPUs get even faster time inefficiency might not be an issue.

Think of other ways of collecting type information.


Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and dicts.


Python's Implicit Interfaces
============================

In python you don't have to define interfaces to declare that classes
use a specific protocol or interface.  There are lots of such examples
in standard library.

For example::
  
  class A(object):
      
      def a_method(self):
          pass
  
  class B(object):
      
      def a_method(self):
          pass
    
  def a_func(arg):
      arg.a_method()
  
  a_func(A())
  a_func(B())

Here although there is no inheritance relations between `A` and `B`,
renaming `A.a_method` should force `B.a_method` to be renamed too.

Or as another example::
  
  a_var = A()
  a_var.a_method()

renaming `a_var.a_method` should rename both `A.a_method` and
`B.a_method`.  That is `a_func` function defines the interface and its
members.

Now the problem is, if rope wants to support implicit interfaces, how
should it find out these interfaces and their members.


Not Supporting Implicit Interfaces
----------------------------------

If we plan not to support implicit interfaces things simplify
considerably.  Function arguments objects are the common base class
of encountered arguments and function returned value object is the
common base class of returned values.


Supporting Implicit Interfaces
------------------------------

We need to find out the way these implicit interfaces are defined.
Actually each function defines an interface for each of its parameters
and the members of this interface are the objects that are passed as
that arguement.  Another thing to keep in mind is that implicit
interfaces are extended by inheritance relation, too.  For example::
  
  class C(A):
      
      def a_method(self):
          pass
  
  def a_func(arg):
      arg.a_method()
  
  another_func(C())

Renaming `arg.a_method` not only should rename `C.a_method` but also it
it should rename `A.a_method`.

We should be careful about situations like::
  
  def a_func(arg):
      if isinstance(arg, A):
          arg.do_something()
      else:
          arg.do_some_other_thing()


Implementation Issues
---------------------

To support implicit interfaces we need to make lots of changes.  First
of all we know that a function parameter can be anything, so using DOI
we have a set of objects for each parameter.  So the question that
comes up here is when do we need parameter objects.

* When refactoring and finding occurrences
* When code assisting in a function

Also for a rename refactoring we need to check all functions and methods
for implicit interfaces that are involved.  This does not seem practical.
Find someway of making it possible.  Maybe we can find
all of the occurrences of a method and for each check whether it is
invoked on a parameter or not.  Now that we have a bigger set of
methods we need to do the same for these methods.  When we're finished
we can perform the actual refactoring.  The challenge here is that we
should consider inheritance relations, too.

Among `PyName` classes `AssignedName`, `ParameterName` and
`ImportedName` might have more than one object.  And I believe
the main place to change is `StatementEvaluator` that might
return a list of pynames in ``${attribute_accesses}.name``
where `attribute_accessses` might result in more than one kind
of pyname.  This implies that `get_pyname_at` might return a list
of pynames.

`objectinfer` should be changed to find all of the objects that can
be inferred.


Builtin Types And Functions
===========================

What should we do about builtin functions and types?

Builtin types:

* list, typle
* dict
* str, unicode
* file
* set, frozenset
* int, float, long, complex
* iterator types
* boolean

Builtin constants:

* False
* True
* None
* NotImplemented
* Ellipsis

Builtin functions:

* range
* super

One approach to builtin types would be to use the `__builtin__` module
dynamically.  The other might be to write classes for the most
interesting ones like `list`\s, `dict`\s and `str`\s.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary

After this refactoring, many places of rope can be refactored.  The
logical line is very useful in many places for instance.


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In futures some of this restrictions might be removed.

* All of the modules should use 4 spaces for indenting and no hard tabs.
* All files that end with ``.py`` are considered to be python files and
  all others not.
* Either all files should be under version control or none.
* All ``*.txt`` files are considered in reST formats.
* XXX


The GUI Mess; Working More on the UI Parts
==========================================


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Not Resetting the Whole Editor
------------------------------

After actions like extract method, we reset the whole editor.  This is
slow and makes the undo difficult.  Find someway of solving this.  I
might be able to use `difflib` module.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?


Handling Multi-key Keyboard Shortcuts
-------------------------------------

Unfortunately `Tk` has problems for handling multi-key keyboard
shortcuts.  We can develop another independant keybinding system that
uses `Tk` to solve these problems.


A Good Keybinding
-----------------

Make a good emacs-ish keybinding.
