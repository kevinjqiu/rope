=============
 Rope Issues
=============


Release Schedule
================

*rope* will be release every two weeks and one final release every
quarter.  That is

=====  ===============
Week   Release Number
=====  ===============
2      x.ym1
4      x.ym2
6      x.ym3
8      x.ym4
10     x.ym5
12     x.yrc1
13     x.y
=====  ===============

This is only a rough plan.  For example some more release candidates
might be released before the ``x.y`` release.


Version 0.3
===========

Time: August 7, 2006 - October 29, 2006


Release Goals
-------------

Metaphor: Try deliver the most interesting values.


Possible Plans
--------------

* Rename class/function
* Extract/Inline methods/functions
* Rename module/package

* Dynamic type inference
* Introduce/Inline temporary variable
* Formatter
* reST go to definition and quick outline
* Better file/folder/module selection dialogs
* Code contexts


Releases
--------

0.3m1
    Done.
0.3m2
    Working on.


To Be Discussed
===============

* Reducing the cost of invalidation
* Saving information for individual objects or only for types
* Should we analyze all source files for holding type hierarchies and
  argument object inference


Choosing The Next Move
======================

If we want to move toward the promised features we need to think about
another refactoring for this week.  But there are other important
issues to think about that have direct effect upon many of remaining
refactorings.  So I think this week I have to put more time in
figuring out the answer to many of these important questions and
possible refactorings.


Having All Modules In Memory
----------------------------

One of the main questions to answer is whether we need to have the
`PyModule` of all modules in the memory. Having all of them in memory
can help:

* For function and arguement object inferencing
* For renaming attributes in a hierarchy
* For having references to an object if enough memory

But this seems very hard to achieve because cpu and memory constraints.
For rope itself holding all modules in memory needs almost ``120mb`` of
memory and ``11s`` of cpu time.  So holding all modules in memory seems
impractical for large projects.


Holding Information For Individual Objects
------------------------------------------

From this respect, we can divide typess into two groups.  The types that
its instances hold valuable and distinct information; examples are
container classes, types, functions and modules.  Types in the second
group hold all information for all instances.  That is instances are
exactly the same.


Lower The Cost Of Module Invalidation
-------------------------------------

When a single module in the project is changed many other modules
are invalidated.  This is very expensive.

Maybe we can separate the concluded data from structure of code.


Argument Object Inference
-------------------------

I think static object inference is hard and right now I consider it
a risk to put much time on it.  I think I should implement dynamic
object inference first.  So I need to put more time on dynamic OI
issues.


Separating Structural From Concluded Data
=========================================

Structure data is function and class definitions, variable assignments.
Conclusions are `PyObject`\s of `PyName`\s.  This move involves many
changes to the implementation of `rope.pyobjects` module but it won't
probably change the APIs.  Since this, if approved, will need big
refactorings it need more thought.


What Do We Gain?
----------------

This separation will dramatically reduce the cost of invalidation.
After doing this separation the structural data do not invalidate and
it is the conclusions that might need to be updated after a module
change.  So the cost of reconstructing `PyModule`\s reduces
considerably.  Also since we don't care about imported `PyName`\s
until when really needed this eliminates some extra time.

Although we lower the memory usage, we propably still can't hold all
`PyModule`\s in memory.

* What does it make easier among goals?
* Is it memory efficient?
* Does it help argument object inference?
* Does it help hierarchies?


Implementation Issues
---------------------

In the constructing the structural part we only care about ``AssName``\s
, ``Function``\s, ``Classes``\s and somehow ``Import``\s.

* new `PyName`\s
* imports
* from imports
* superclasses


How To Hold Concluded Information?
----------------------------------

Where should we store concluded data.  We should be able to invalidate
those data too.

What does these data contain exactly?


Finding Occurances
==================

For doing many refactoring we need to find occurances of an object.
Find an efficient way of doing it.  Currently rope tries to find
occurences by textually searching for the variable name and for each
suspected name we check whether this name points to the object we are
interested in or not.  This seems slow when the number of similar
names is considerable.  Having a type database?


Limiting the scope for searching
--------------------------------

Rope searches all python files for a name.  But this seems unnecessary
for local variables or modules that does not import that name.


Infering Function Argument Objects
==================================

Function argument object inference seem to be very important for
continuing our efforts in refactorings.


Container Types Require Call Information
========================================

We need to know the type `list`\s and `dict`\s hold. This is actually
a special case of knowing function argument objects.


Refactoring Issues
==================

Getting Source Code Or Resource?
--------------------------------

Considering the changes refactorings may make, we can devide them into
two groups:

* those that only change one piece of code
* those that change multiple files

For the second group, the `Refactoring` class should work on resources
and make changes to them directly, but for the first group only
passing the source code of one resource suffices.  The problem is
that undo refactoring only works when we make changes to resources
directly. Changing refactorings in the first group to use resources
have the following consequences:

* Undo refactoring will work on them, too.
* All editors should be saved before performing them.


AST Writer Might Be A Mistake
-----------------------------

Until recently I was thinking about the problems of working with ASTs
for refactorings.  Now I feel that there might be other ways of
transforming source code for refactorings.

Many of refactorings only require the references to a name to be
replaced with another.  This can be done without using ASTs.
Refactorings like inline/extract function can be done without using
AST's, too.


Classifying Object Inference Goals
==================================

Here is the list of goals that we want to achieve in the TI parts
of rope:

* Finding occurances of variables
* Support for more advanced refactorings that need the object
  of arguements
* Code assist for container types
* Code assist for function arguments


Dyanmic Type Inference Issues
=============================

Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and dicts.


External program execution
--------------------------

Because the program is executed in a separate process we should find
someway for transfering information back to the main process.  I
believe we have to execute the program in a separate process because
of these possible problems:

* Getting out of memory
* Having more control on the process for tracing function calls
* Changing interrupt handling
* Security

We should also keep in mind that we should probably be able to
transfer input/output to the running program, too.  To transfer
information we might be able to use:

* Files
* Standard input/output
* Shared memory
* Network sockets

The thing to keep in mind is that we want the result to be as
deterministic as possible and it should be easily used in tests, too.
(or at least there should be a good place holder implementation
available).


Transferring Data
-----------------

We need to send the module to be run to the runner and get collected
data.


Where To Analyze Data?
----------------------

As program is executed we collect function call data.  But the question
is whether the runner or rope should analyze them.  If we use file
for transfering, data should be analyze before writing to file because
the amount of required memory is substantial.


Analyzing Data
--------------

The input data are function call information; ie ``(called_function,
passed_args, returned_object)``.  In order to use these collected
data we need to either:

* store function return types for each call
* store function return types for each set of argument types
  (Cartesian Product algorithm)

The first approach doesn't seem reasonable because of memory inefficiency.


Organizing And Saving Data
--------------------------

Can we store all information in a database?


Can't We Start Static Type Inference?
=====================================

I need to think about the problems that might arise for static TI.
Now I think that static TI is not that hard and in dynamic TI some of
the approaches in static TI is used.  The difference is in the type
inference of the function returned objects.  In the dynamic TI
approach we use our database and in static TI we follow the return
statement.

For static type inference, we need some changes to the
`_FunctionVisitor` class to collect the return AST nodes, too.  When
we want to find out the returned type of the function, we look up in a
dictionary for the given argument types.  If it is already calculated
we return it, otherwise we type inference returned statement
recursively.  A new question arises here and that is how we set the
`PyObject` of argument `PyName`\s.

There is some complex issues about type inferencing variables in
functions, too.  For type inferencing a local variable we might need
to have `PyObject`\s of arguements but we don't know the type of
arguments.  In dynamic TI we can record the type of arguments and use
them when needed.  But in static TI it is much harder because we need
to find function calls and type inference the arguements that are
passed to the function.

So as a conclusion it seems better to mix static and dynamic TI.
Static type inference seem to work good for general cases while
dynamic inference seems more suitable for type inference of long
chains of function calls and function arguments.  This means to use
dynamic TI when static TI does not work or is expensive.


Which Is Right? Type Or Object Inference
========================================

Should we use type inference or object inference? I believe object
inference is better.  What we try do is to infer the object a variable
references during program execution.  Sometimes we are only interested
in the type of the referenced object and sometimes we need the object
itself.  This latter situation occurs when an instance holds
interesting information that does not exist in its type.

As an example classes(types) are instances of `type` class.  That is
their type is `type`.  But knowing their type does not give us much
information about the methods defined in these derived classes.


Getting Buried In Layers
========================

Starting from `rope.pycore` module, there are many layers that are
hidden beneath it.  Most of unit tests only test `PyCore` directly and
other parts are tested indirectly through many layers that lead to
`PyCore`.  I guess this is a bad sign.  Maybe I should put more time
in making each layer more testable and independant of other layers.


Better Scope Finding Algorithm
==============================

The current implementation is very slow and recently I've moved
finding inner scope parts to `GlobalScope` class.  However the new
implementation would be if it does not recompute the same information
for each call it is a lot faster than the current implementation.

By caching `Scope.get_scope_end` method, we can use current
implementation with small changes.


Problems With The Current Way Of Finding Scope
----------------------------------------------

When getting the scope for the first line of a function, function
header, we get that it belongs to the parent scope.  This is not
correct but this line does not belong to the function scope either.
Actually the function name part of function header belongs to the
parents scope and the arguments part belongs to function scope.

I can't think of any good way of doing that and maybe the best thing I
can do is to check for this exception when finding scopes.  Think
about other exceptions.  Does a similar situation occur for classes
too? What about ``for`` loops?

If the problem only occurs for functions I think the exception
approach would be a good solution.  But the problem is that the scope
finding part is separate from refactoring part.


Builtin Types And Functions
===========================

What should we do about builtin functions and types?

Builtin types:

* list, typle
* dict
* str, unicode
* file
* set, frozenset
* int, float, long, complex
* iterator types
* boolean

Builtin constants:

* False
* True
* None
* NotImplemented
* Ellipsis

Builtin functions:

* range
* super

One approach to builtin types would be to use the `__builtin__` module
dynamically.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary

After this refactoring, many places of rope can be refactored.  The
logical line is very useful in many places for instance.


The GUI Mess; Working More On The UI Parts
==========================================

My ignorance to UI has make some modules like `rope.ui.core` and
`rope.ui.editor` very large and full of duplication.  These modules
need many refactorings.  Put more time on these modules.


Introducing Extension Points
----------------------------

Define Some extension points for the UI.  I think ``menu`` and ``key``
extension points are enough for now.  A difficulty for using extension
points is that extensions may be meaningful only in some contexts.
For example when no editor is open the ``Edit`` menu does not make any
sense or when not editing a python file the ``Run Module`` menu item
is meaningless.  Even in a context a menu item might be disabled
sometimes; like ``undo`` menu item.

Forgetting all these constraints we'd rather start with a simple hack.
The first thing to keep in mind is that after this refactoring we
probably want to put code assist dialogs in the same module maybe
`rope.ui.codeassist`.  After this refactoring `rope.ui.editor` will
contain only things that directly deal with editing and `rope.ui.core`
only contains features that directly deal with files and projects.  Or
maybe we can factor these things to a `rope.ui.filedialogs` module.

One of the main things to decide about is how to register these
callbacks to one of these extension points.  The easiest thing may be
to specify the modules that contain extensions.  `Core` class loads
those modules when needed.  We can either *push* or *pull* the data.
In the push method as a module is being loaded it registers its
components using methods that `Core` class makes available.
Alternatively in the pull model, the module can set some variables
that hold the data for registering the plugins.  When the modules
are loaded, `Core` reads those variables and registers those
components.

Another issue is how to pass `Core` or any needed context information
to these callbacks when they should execute; probably as arguments.


Shifting To `Action`\s
~~~~~~~~~~~~~~~~~~~~~~

After the addition of `rope.ui.extension` module followed by the
addition modules like `rope.ui.codeassist`, we have to gradually move
related dialogs to this modules.  This helps `Core` and `Editor`
modules not to be so much messy.


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue
using `rope.ui.uihelpers` module and extend it.


Not Resetting The Whole Editor
------------------------------

After actions like extract method, we reset the whole editor.  This
is slow and makes the undo difficult.  Find someway of solving this.
I might be able to use `difflib` module.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining The Responsibilities Of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?

