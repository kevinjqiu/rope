=============
 Rope Issues
=============


Release Schedule
================

*rope* will be release every two weeks and one final release every
quarter.  That is

=====  ===============
Week   Release Number
=====  ===============
2      x.ym1
4      x.ym2
6      x.ym3
8      x.ym4
10     x.ym5
12     x.yrc1
13     x.y
=====  ===============

This is only a rough plan.  For example some more release candidates
might be released before the ``x.y`` release.


Version 0.3
===========

Time: August 7, 2006 - October 29, 2006

Metaphor: Deliver the most interesting values.


Possible Plans
--------------

* Dynamic type inference
* Rename class/function
* Extract/Inline methods/functions
* Introduce/Inline temporary variable
* Formatter
* Rename module/package
* reST go to definition and quick outline
* Better file/folder/module selection dialogs
* Code contexts


Releases
--------

0.3m1
    Working on.


Release Goals
-------------

Bottlenecks
    ...

Repairs
    Some UI parts need to be refactored.  Better GUI and functional
    tests.

Themes
    rope needs values.  Our next move toward the proposed features
    would be to provide as many as refactorings as possible.

Stories
    ...

Big Picture
    ...


To Be Discussed
===============

* Reducing the cost of invalidation


Finding Occurances
==================

For doing many refactoring we need to find occurances of an object.
Find an efficient way of doing it.  Currently rope tries to find
occurences by textually searching for the variable name and for each
suspected name we check whether this name points to the object we are
interested in or not.  This seems slow when the number of similar
names is considerable.  Having a type database?


Limiting the scope for searching
--------------------------------

Rope searches all python files for a name.  But this seems unnecessary
for local variables or modules that does not import that name.


Infering Function Argument Objects
==================================

Function argument object inference seem to be very important for
continuing our efforts in refactorings.


Supporting Relative Imports
===========================

Right now rope does *not* support relative imports.  One reason is
that the syntax for relative imports is changing in python ``2.5``.
The new relative import syntax will be supported by *rope* before
python ``2.5`` release.  Think about supporting the old syntax.


Container Types Require Call Information
========================================

We need to know the type `list`\s and `dict`\s hold. This is actually
a special case of knowing function argument objects.


Refactoring Issues
==================

Getting Source Code Or Resource?
--------------------------------

Considering the changes refactorings may make, we can devide them into
two groups:

* those that only change one piece of code
* those that change multiple files

For the second group, the `Refactoring` class should work on resources
and make changes to them directly, but for the first group only
passing the source code of one resource suffices.  The problem is
that undo refactoring only works when we make changes to resources
directly. Changing refactorings in the first group to use resources
have the following consequences:

* Undo refactoring will work on them, too.
* All editors should be saved before performing them.


AST Writer Might Be A Mistake
-----------------------------

Until recently I was thinking about the problems of working with ASTs
for refactorings.  Now I feel that there might be other ways of
transforming source code for refactorings.

Many of refactorings only require the references to a name to be
replaced with another.  This can be done without using ASTs.
Refactorings like inline/extract function can be done without using
AST's, too.


Classifying Object Inference Goals
==================================

Here is the list of goals that we want to achieve in the TI parts
of rope:

* Finding occurances of variables
* Support for more advanced refactorings that need the object
  of arguements
* Code assist for container types
* Code assist for function arguments


Dyanmic Type Inference Issues
=============================

Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.

What to save when executing:

* Storing function return types for each call
* Storing function return types for each set of argument types
  (Cartesian Product algorithm)


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the objects is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and maps.


External program execution
--------------------------

Because the program is executed in a separate process we should find
someway for transfering information back to the main process.  I
believe we have to execute the program in a separate process because
of these possible problems:

* Getting out of memory
* Having more control on the process for tracing function calls
* Changing interrupt handling
* Security

We should also keep in mind that we should probably be able to
transfer input/output to the running program, too.  To transfer
information we might be able to use:

* Files
* Standard input/output
* Shared memory
* Network sockets

The thing to keep in mind is that we want the result to be as
deterministic as possible and it should be easily used in tests, too.
(or at least there should be a good place holder implementation
available).


Probable Refactorings
---------------------

* More separation of `PyObject`\s and `PyName`\s


Holding Source Code In `PyModule`
---------------------------------

In order to add `GlobalScope.get_inner_scope_for_line` we need to hold
the source code in `PyModule`.  This might consume lots of memory.
But right now I don't think that it is a problem.  So I will do that.


Passing `ObjectInfer` Object To `PyName`\s
------------------------------------------

One way would be having one `ObjectInfer` instance in `PyCore`.  But
`PyName`\s don't hold an instance to `PyCore`\s, not do all of
`PyObject`\s.  Only `PyDefinedObject`\s do that.  The simplest
approach would be to use `PyName.module` but we should keep in mind
that it is ``None`` for modules that cannot be found.  This might be a
*noticeable issue* in future.


Can't We Start Static Type Inference?
=====================================

I need to think about the problems that might arise for static TI.
Now I think that static TI is not that hard and in dynamic TI some of
the approaches in static TI is used.  The difference is in the type
inference of the function returned objects.  In the dynamic TI
approach we use our database and in static TI we follow the return
statement.

For static type inference, we need some changes to the
`_FunctionVisitor` class to collect the return AST nodes, too.  When
we want to find out the returned type of the function, we look up in a
dictionary for the given argument types.  If it is already calculated
we return it, otherwise we type inference returned statement
recursively.  A new question arises here and that is how we set the
`PyObject` of argument `PyName`\s.

There is some complex issues about type inferencing variables in
functions, too.  For type inferencing a local variable we might need
to have `PyObject`\s of arguements but we don't know the type of
arguments.  In dynamic TI we can record the type of arguments and use
them when needed.  But in static TI it is much harder because we need
to find function calls and type inference the arguements that are
passed to the function.

So as a conclusion it seems better to mix static and dynamic TI.
Static type inference seem to work good for general cases while
dynamic inference seems more suitable for type inference of long
chains of function calls and function arguments.  This means to use
dynamic TI when static TI does not work or is expensive.


Which Is Right? Type Or Object Inference
========================================

Should we use type inference or object inference? I believe object
inference is better.  What we try do is to infer the object a variable
references during program execution.  Sometimes we are only interested
in the type of the referenced object and sometimes we need the object
itself.  This latter situation occurs when an instance holds
interesting information that does not exist in its type.

As an example classes(types) are instances of `type` class.  That is
their type is `type`.  But knowing their type does not give us much
information about the methods defined in these derived classes.


Getting Buried In Layers
========================

Starting from `rope.pycore` module, there are many layers that are
hidden beneath it.  Most of unit tests only test `PyCore` directly and
other parts are tested indirectly through many layers that lead to
`PyCore`.  I guess this is a bad sign.  Maybe I should put more time
in making each layer more testable and independant of other layers.


Better Scope Finding Algorithm
==============================

The current implementation is very slow and recently I've moved
finding inner scope parts to `GlobalScope` class.  However the new
implementation would be if it does not recompute the same information
for each call it is a lot faster than the current implementation.

By caching `Scope.get_scope_end` method, we can use current
implementation with small changes.


Problems With The Current Way Of Finding Scope
----------------------------------------------

When getting the scope for the first line of a function, function
header, we get that it belongs to the parent scope.  This is not
correct but this line does not belong to the function scope either.
Actually the function name part of function header belongs to the
parents scope and the arguments part belongs to function scope.

I can't think of any good way of doing that and maybe the best thing I
can do is to check for this exception when finding scopes.  Think
about other exceptions.  Does a similar situation occur for classes
too? What about ``for`` loops?

If the problem only occurs for functions I think the exception
approach would be a good solution.  But the problem is that the scope
finding part is separate from refactoring part.


Builtin Types And Functions
===========================

What should we do about builtin functions and types?

Builtin types:

* list, typle
* dict
* str, unicode
* file
* set, frozenset
* int, float, long, complex
* iterator types
* boolean

Builtin constants:

* False
* True
* None
* NotImplemented
* Ellipsis

Builtin functions:

* range
* super

One approach to builtin types would be to use the `__builtin__` module
dynamically.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary


The GUI Mess; Working More On The UI Parts
==========================================

My ignorance to UI has make some modules like `rope.ui.core` and
`rope.ui.editor` very large and full of duplication.  These modules
need many refactorings.  Put more time on these modules.


Introducing Extension Points
----------------------------

Define Some extension points for the UI.  I think ``menu`` and
``key`` extension points are enough for now.  A difficulty for using
extension points is that extensions may be meaningful only in some
contexts.  For example when no editor is open the ``Edit`` menu does
not make any sense or when not editing a python file the
``Run Module`` menu item is meaningless.  Even in a context a menu
item might be disabled sometimes; like ``undo`` menu item.


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue
using `rope.ui.uihelpers` module and extend it.

Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


