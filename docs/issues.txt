=============
 Rope Issues
=============


Release Schedule
================

*rope* will be release every two weeks and one final release every
quarter.  That is

=====  ===============
Week   Release Number
=====  ===============
2      x.ym1
4      x.ym2
6      x.ym3
8      x.ym4
10     x.ym5
12     x.yrc1
13     x.y
=====  ===============

This is only a rough plan.  For example some more release candidates
might be released before the ``x.y`` release.


Version 0.3
===========

Time: August 7, 2006 - October 29, 2006


Release Goals
-------------

Metaphor: Try deliver the most interesting values.


Possible Plans
--------------

* Rename class/function
* Extract/Inline methods/functions
* Rename module/package

* Dynamic type inference
* Introduce/Inline temporary variable
* Formatter
* reST go to definition and quick outline
* Better file/folder/module selection dialogs
* Code contexts


Releases
--------

0.3m1
    Done.
0.3m2
    Working on.


To Be Discussed
===============

* Reducing the cost of invalidation
* Saving information for individual objects or only for types
* Should we analyze all source files for holding type hierarchies and
  argument object inference


Choosing The Next Move
======================

If we want to move toward the promised features we need to think about
another refactoring for this week.  But there are other important
issues to think about that have direct effect upon many of remaining
refactorings.  So I think this week I have to put more time in
figuring out the answer to many of these important questions and
possible refactorings.


Having All Of The Modules In Memory
-----------------------------------

One of the main questions to answer is whether we need to have the
`PyModule` of all modules in the memory. Having all of them in memory
can help:

* For function and arguement object inferencing
* For renaming attributes in a hierarchy
* For having references to an object if enough memory

But this seems very hard to achieve because cpu and memory
constraints.  For rope itself holding all modules in memory needs
almost ``120mb`` of memory and ``11s`` of cpu time.  So holding all
modules in memory seems impractical for large projects.


Holding Information For Individual Objects
------------------------------------------

From this respect, we can divide typess into two groups.  The types
that its instances hold valuable and distinct information; examples
are container classes, types, functions and modules.  Types in the
second group hold all information for all instances.  That is
instances are exactly the same.


Lower The Cost Of Module Invalidation
-------------------------------------

When a single module in the project is changed many other modules are
invalidated.  This is very expensive.

Maybe we can separate the concluded data from structure of code.


Argument Object Inference
-------------------------

I think static object inference is hard and right now I consider it a
risk to put much time on it.  I think I should implement dynamic
object inference first.  So I need to put more time on dynamic OI
issues.


Separating Structural From Concluded Data
=========================================

Structural data are function and class definitions, variable
assignments and imports.  Conclusions are `PyObject`\s of `PyName`\s.
This move involves many changes to the implementation of
`rope.pyobjects` module but it won't probably change the APIs.  Since
this, if approved, will need big refactorings it need more thought.


What Do We Gain?
----------------

This separation will dramatically reduce the cost of invalidation.
After doing this separation the structural data do not invalidate and
it is the conclusions that might need to be updated after a module
change.  So the cost of reconstructing `PyModule`\s reduces
considerably.  Also since we don't care about imported `PyName`\s
until when really needed this eliminates some extra time.

Although we lower the memory usage, we propably still can't hold all
`PyModule`\s in memory.

* What does it make easier among goals?
* Is it memory efficient?
* Does it help argument object inference?
* Does it help hierarchies?


Implementation Issues
---------------------

In the construction of structural parts we only care about
``AssName``\s , ``Function``\s, ``Class``\es and somehow
``Import``\s.

* new `PyName`\s
* imports
* from imports
* superclasses


How To Hold Concluded Information?
----------------------------------

Where should we store concluded data.  We should be able to invalidate
those data too.

What does these data contain exactly?


Finding Occurances
==================

For doing many refactoring we need to find occurances of an object.
Find an efficient way of doing it.  Currently rope tries to find
occurences by textually searching for the variable name and for each
suspected name we check whether this name points to the object we are
interested in or not.  This seems slow when the number of similar
names is considerable.  Having a type database?


Limiting the scope for searching
--------------------------------

Rope searches all python files for a name.  But this seems unnecessary
for local variables or modules that does not import that name.


Refactoring Issues
==================

Getting Source Code Or Resource?
--------------------------------

Considering the changes refactorings may make, we can devide them into
two groups:

* those that only change one piece of code
* those that change multiple files

For the second group, the `Refactoring` class should work on resources
and make changes to them directly, but for the first group only
passing the source code of one resource suffices.  The problem is that
undo refactoring only works when we make changes to resources
directly. Changing refactorings in the first group to use resources
have the following consequences:

* Undo refactoring will work on them, too.
* All editors should be saved before performing them.


Classifying Object Inference Goals
==================================

Here is the list of goals that we want to achieve in the TI parts
of rope:

* Finding occurances of variables
* Support for more advanced refactorings
* Code assist for container types
* Code assist for function arguments


Dyanmic Type Inference Issues
=============================

Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and dicts.


External program execution
--------------------------

Because the program is executed in a separate process we should find
someway for transfering information back to the main process.  I
nbelieve we have to execute the program in a separate process because
of these possible problems:

* Getting out of memory
* Having more control on the process for tracing function calls
* Changing interrupt handling
* Security

We should also keep in mind that we should probably be able to
transfer input/output to the running program, too.  To transfer
information we might be able to use:

* Files
* Standard input/output
* Shared memory
* Network sockets

The thing to keep in mind is that we want the result to be as
deterministic as possible and it should be easily used in tests, too.
(or at least there should be a good placeholder implementation
available).


Analyzing Data
--------------

The input data are function call information; ie ``(called_function,
passed_args, returned_object)``.  In order to use these collected data
we need to either:

* store function return types for each call
* store function return types for each set of argument types
  (something like Cartesian Product algorithm)

The first approach doesn't seem reasonable because of memory
inefficiency.


Optimizing DOI
--------------

The current implementation is very slow.  For the cpu time I found out
that the bottle-neck is not on the rope side or sending data.  One of
the main problems is that using `inspect` module for finding the line
number of classes is very inefficient.


Using `sys.settrace` Better
~~~~~~~~~~~~~~~~~~~~~~~~~~~

After setting the trace function, it is called everytime we are
entering a new local scope and asked for a local trace function.  So
we can ignore some of these local scopes that are not interesting.  If
we have lots of uninteresting function calls this will help much.  So
now the problem is which function calls are not interesting.

In the following table we list all possible function calls.  The
``from`` field means the location of the caller of a method and the
``to`` field means the location of the method itself.  ``in`` stands
for inside project and ``out`` stands for outside project.

======  ======  ==============
from    to      interesting?
======  ======  ==============
in      in      yes
in      out     yes
out     in      yes
out     out     no
======  ======  ==============

So the only unintersting group is the group of functions outside the
project that call another function outside project.  This does not
help us much.  Because we should ignore a local scope completely or
not.

If we think about the interesting ``out to in`` group, they are
nothing but the callbacks that a function outside project calls the
inside ones.  If we ignore our interest in this group we'll be able to
ignore all of the local scopes that are out of the project (Since we
are not interested in ``out to out`` group as well).  But it depends
on whether the program has many of these ``out to in`` calls or not.
For a typical program these calls are very few.  They might be from an
event handling system or some special visitor functions in standard
library.  This issue needs more thought.


`inspect`'s Simplistic Way Of Finding Classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`inspect` module does a simple text search for finding a class.  `inspect`
fails to find the correct class here.::

  def a_func():
      class AClass(object):
          pass
  
  class AClass(object):
      pass

If you ask `inspect` to give you the first line of `AClass` it will
give you ``2`` while the correct answer is ``5``.  Apart from this bug
`inspect` is very slow for finding the starting line number of a class
definition.

I think I can implement that much faster.  For this reason I should
extend the way I pass objects to rope.  For classes and instances I
should be able to say the name of the class and its containing module.
I can calculate the real object when necessary.  For finding the real
objects first I can search module global scope.  If it wasn't there I
can use the approach that `inspect` uses.  This approach is very good
because most classes are defined in the global scope.

Although this approach outperforms `inspect` module, does lazy
computation (only when getting the real object) and passes the above
test, it fails in a more complex situation where there are two classes
with the same name inside two different nested scopes.


Better Attribute Object Inference
=================================

Consider this situation::
  
  class AClass(object):
      
      def __init__(self):
          self.an_attr = None
      
      def set_attr(self, new_value):
          self.an_attr = self.new_value

This situation occurs rather frequently, specially when using lazy
initialization.  Another common situation is in test cases where
variables are defined in `setUp` method rather than `__init__`.


Which Is Right? Type Or Object Inference
========================================

Should we use type inference or object inference? I believe object
inference is better.  What we try do is to infer the object a variable
references during program execution.  Sometimes we are only interested
in the type of the referenced object and sometimes we need the object
itself.  This latter situation occurs when an instance holds
interesting information that does not exist in its type.

As an example classes(types) are instances of `type` class.  That is
their type is `type`.  But knowing their type does not give us much
information about the methods defined in these derived classes.


Getting Buried In Layers
========================

Starting from `rope.pycore` module, there are many layers that are
hidden beneath it.  Most of unit tests only test `PyCore` directly and
other parts are tested indirectly through many layers that lead to
`PyCore`.  I guess this is a bad sign.  Maybe I should put more time
in making each layer more testable and independant of other layers.


Builtin Types And Functions
===========================

What should we do about builtin functions and types?

Builtin types:

* list, typle
* dict
* str, unicode
* file
* set, frozenset
* int, float, long, complex
* iterator types
* boolean

Builtin constants:

* False
* True
* None
* NotImplemented
* Ellipsis

Builtin functions:

* range
* super

One approach to builtin types would be to use the `__builtin__` module
dynamically.  The other might be to write classes for the most
interesting ones like `list`\s, `dict`\s and `str`\s.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary

After this refactoring, many places of rope can be refactored.  The
logical line is very useful in many places for instance.


The GUI Mess; Working More On The UI Parts
==========================================

My ignorance to UI has make some modules like `rope.ui.core` and
`rope.ui.editor` very large and full of duplication.  These modules
need many refactorings.  Put more time on these modules.


Introducing Extension Points
----------------------------

Define Some extension points for the UI.  I think ``menu`` and ``key``
extension points are enough for now.  A difficulty for using extension
points is that extensions may be meaningful only in some contexts.
For example when no editor is open the ``Edit`` menu does not make any
sense or when not editing a python file the ``Run Module`` menu item
is meaningless.  Even in a context a menu item might be disabled
sometimes; like ``undo`` menu item.

Forgetting all these constraints we'd rather start with a simple hack.
The first thing to keep in mind is that after this refactoring we
probably want to put code assist dialogs in the same module maybe
`rope.ui.codeassist`.  After this refactoring `rope.ui.editor` will
contain only things that directly deal with editing and `rope.ui.core`
only contains features that directly deal with files and projects.  Or
maybe we can factor these things to a `rope.ui.filedialogs` module.

One of the main things to decide about is how to register these
callbacks to one of these extension points.  The easiest thing may be
to specify the modules that contain extensions.  `Core` class loads
those modules when needed.  We can either *push* or *pull* the data.
In the push method as a module is being loaded it registers its
components using methods that `Core` class makes available.
Alternatively in the pull model, the module can set some variables
that hold the data for registering the plugins.  When the modules
are loaded, `Core` reads those variables and registers those
components.

Another issue is how to pass `Core` or any needed context information
to these callbacks when they should execute; probably as arguments.


Shifting To `Action`\s
~~~~~~~~~~~~~~~~~~~~~~

After the addition of `rope.ui.extension` module followed by the
addition modules like `rope.ui.codeassist`, we have to gradually move
related dialogs to this modules.  This helps `Core` and `Editor`
modules not to be so much messy.


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Not Resetting The Whole Editor
------------------------------

After actions like extract method, we reset the whole editor.  This is
slow and makes the undo difficult.  Find someway of solving this.  I
might be able to use `difflib` module.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining The Responsibilities Of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?


Handling Multi-key Keyboard Shortcuts
-------------------------------------

Unfortunately `Tk` has problems for handling multi-key keyboard
shortcuts.  We can develop another independant keybinding system that
uses `Tk` to solve these problems.
