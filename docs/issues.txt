=============
 Rope Issues
=============


Release Schedule
================

*rope* will be release every two weeks and one final release every
quarter.  That is

=====  ===============
Week   Release Number
=====  ===============
2      x.ym1
4      x.ym2
6      x.ym3
8      x.ym4
10     x.ym5
12     x.yrc1
13     x.y
=====  ===============

This is only a rough plan.  For example some more release candidates
might be released before the ``x.y`` release.


Version 0.3
===========

From August 7, 2006 till November 5, 2006


Release Goals
-------------

Metaphor: Deliver the most interesting features


Possible Plans
--------------

* Dynamic type inference
* Move class/function/module/package
* Introduce factory method
* Encapsulate method
* Introduce/Inline temporary variable
* Formatter
* reST go to definition and quick outline
* Code contexts


Releases
--------

0.3m1
    Done.
0.3m2
    Done.
0.3m3
    Done.
0.3m4
    Working on.


This Release
------------

* Separating Structural From Concluded Data
* Enhanced Import Tools
* Introduce factory method refactoring

* `Move function/class refactoring`_


Hot Topics
==========

* `Undo Unification`_
* `Encapsulate Field Refactoring`_
* `Python's Implicit Interfaces`_


To Be Discussed
===============

* Changing relative imports in refactorings
* Function to function object refactoring
* Getting code completion on ``except`` line

* Rope's preference saving system: format, location
* Having a persistant format for PyNames and PyObjects for saving
  hard to compute information like class hierarchies
* Using a modification of `compiler` AST for simplifying refactorings
* `What rope assumes...`_


Move Function/Class Refactoring
===============================

Another problem is we can find out the imports used in a class or
function body using `get_used_imports` but there might be some other
global classes or functions in the source module that are used by
the moving element.  On the other hand some imports might be
unnecessary because we are importing objects that are defined in the
destination module.  The simple approach to the first problem is
importing star from the source module.  Later we can use expand star
to remove unneeded imports.  Unfortunately I think this approach
might cause circular imports.


Encapsulate Field Refactoring
=============================

We should divide program source code into two sections.  The section
in which references to an attribute should be replaced with getters
and setters and the section that shouldn't.  The latter consists of
class constructor or maybe all functions inside the class and the
former consists of all other places.


Multi-Step Refactorings
=======================

Some of the refactorings need to be performed in multi steps.  In
such situations I believe I have to use `PyCore.get_string_module`.
So for refactorings like rename there should be a method that works
on `PyModule`\s rather than `Resource`\s.  The problem with this
approach is that other modules might need to have access to a changed
module, but since the change is not committed, it is not possible. So
we might need to add another layer on the `PyCore.get_module`, but
that seems like a big refactoring.

Another approach is doing refactorings in each step before going
to the next one.  In this approach we won't be able to preview
before performing the refactoring.


Do We Really Need to Access Changed Modules?
--------------------------------------------

I think we can do refactorings like move method or introduce
factory without having access to changed modules.


Undo Unification
================

Currently there are separate undo actions for editing text and
refactorings and in future there might be undos for other changes.
We need to mix them together.  This seems hard to do mainly because
we don't have much access to the undo mechanism of Tkinter.  I think
an approximation here will save us.


Enhanced Import Tools
=====================

First we should find out what we need exactly.  We need better import
analysis and manipulation tools to help us do many refactorings such
as:

* Move method might require some imports to be moved to.
* Introduce factory method might need to import the method.
* Inline method might require to add and remove some imports.
* Transform module to package might change relative imports.

Organizing imports:

* Eliminate star imports
* Remove duplicates
* Remove unused
* Relative to absolute
* Relative to new relative
* From to import
* Import to from


Separating Structural From Concluded Data
=========================================

Structural data are function and class definitions, variable
assignments and imports.  Conclusions are `PyObject`\s of `PyName`\s.
This move involves many changes to the implementation of
`rope.pyobjects` module but it won't probably change the APIs.  Since
this, if approved, will need big refactorings it need more thought.


What Do We Gain?
----------------

This separation will dramatically reduce the cost of invalidation.
After doing this separation the structural data do not invalidate and
it is the conclusions that might need to be updated after a module
change.  So the cost of reconstructing `PyModule`\s reduces
considerably.  Also since we don't care about imported `PyName`\s
until when really needed this eliminates some extra time.

Although we lower the memory usage, we propably still can't hold all
`PyModule`\s in memory.


Implementation Issues
---------------------

In the construction of structural parts we only care about
``AssName``\s , ``Function``\s, ``Class``\es and somehow
``Import``\s.

* new `PyName`\s
* imports
* from imports
* superclasses


Finding Occurances
==================

For doing many refactoring we need to find occurances of an object.
Find an efficient way of doing it.  Currently rope tries to find
occurences by textually searching for the variable name and for each
suspected name we check whether this name points to the object we are
interested in or not.  This seems slow when the number of similar
names is considerable.  Having a type database?


Limiting the Scope for Searching
--------------------------------

Rope searches all python files for a name.  But this seems unnecessary
for local variables or modules that does not import that name.


Adding SVN Support Using `pysvn`
================================

Currently `rope.fscommands` module makes an all or nothing assumption.
Either all or none of the files should be under version control.

We should be able to make transaction so that if an error occurs
during one action we can revert back.


Dyanmic Type Inference Issues
=============================

Saving Collected Data
---------------------

Since resources might change after DTI, we should save collected data
so that they can be used even if there are small changes in some
files.  There might be two approaches to this problem.

In the first approach we can make `PyName`\s and `PyObject`\s
reference objects so that they can be used persistantly.  This
approach seems hard due to problems that might arise for updating
`PyName`\s.

The second approach seems easier to implement.  We can save collected
type information somewhere outside `PyName`\s.  Each time we need a
`PyName`\'s object we use that data store it.  In this approach we
should find someway of storing collected data that it can be used even
if there are some small changes in a resource.  The simplest way of
saving collected data is the ``(file, lineno)`` tuple.  The other is
the hierarchical representation and in this approach we save the data
like ``file.class.method``.


Returned Types Or Objects
-------------------------

Should we care only about the type of the returned object or we should
consider the object itself too?

Well, it depends on the type of the objects that is returned.  If it
is an instance of a class then only the type matters.  If it is a
function, module or class then the object is important.

Indeed you should make some difference between the objects that we
only care about their types and the objects that their individual
characters is important to us.  Right now the latter group contains
only functions, classes and modules but this list will probably be
extended when we start holding information for individual objects like
lists and dicts.


Optimizing DOI
--------------

We should make `run module` more efficient.


Using `sys.settrace` Better
~~~~~~~~~~~~~~~~~~~~~~~~~~~

After setting the trace function, it is called everytime we are
entering a new local scope and asked for a local trace function.  So
we can ignore some of these local scopes that are not interesting.  If
we have lots of uninteresting function calls this will help much.  So
now the problem is which function calls are not interesting.

In the following table we list all possible function calls.  The
``from`` field means the location of the caller of a method and the
``to`` field means the location of the method itself.  ``in`` stands
for inside project and ``out`` stands for outside project.

======  ======  ==============
from    to      interesting?
======  ======  ==============
in      in      yes
in      out     yes
out     in      yes
out     out     no
======  ======  ==============

So the only unintersting group is the group of functions outside the
project that call another function outside project.  This does not
help us much.  Because we should ignore a local scope completely or
not.

If we think about the interesting ``out to in`` group, they are
nothing but the callbacks that a function outside project calls the
inside ones.  If we ignore our interest in this group we'll be able to
ignore all of the local scopes that are out of the project (Since we
are not interested in ``out to out`` group as well).  But it depends
on whether the program has many of these ``out to in`` calls or not.
For a typical program these calls are very few.  They might be from an
event handling system or some visitor functions in standard library.
This issue needs more thought.


`inspect`'s Simplistic Way Of Finding Classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`inspect` module does a simple text search for finding a class.  `inspect`
fails to find the correct class here.::

  def a_func():
      class AClass(object):
          pass
  
  class AClass(object):
      pass

If you ask `inspect` to give you the first line of `AClass` it will
give you ``2`` while the correct answer is ``5``.  Apart from this bug
`inspect` is very slow for finding the starting line number of a class
definition.

I think I can implement that much faster.  For this reason I should
extend the way I pass objects to rope.  For classes and instances I
should be able to say the name of the class and its containing module.
I can calculate the real object when necessary.  For finding the real
objects first I can search module global scope.  If it wasn't there I
can use the approach that `inspect` uses.  This approach is very good
because most classes are defined in the global scope.

Although this approach outperforms `inspect` module, does lazy
computation (only when getting the real object) and passes the above
test, it fails in a more complex situation where there are two classes
with the same name inside two different nested scopes.


Python's Implicit Interfaces
============================

In python you don't have to define interfaces to declare that classes
use a specific protocol or interface.  There are lots of such examples
in standard library.

For example::
  
  class A(object):
      
      def a_method(self):
          pass
  
  class B(object):
      
      def a_method(self):
          pass
    
  def a_func(arg):
      arg.a_method()
  
  a_func(A())
  a_func(B())

Here although there is no inheritance relations between `A` and `B`,
renaming `A.a_method` should force `B.a_method` to be renamed too.

Or as another example::
  
  a_var = A()
  a_var.a_method()

renaming `a_var.a_method` should rename both `A.a_method` and
`B.a_method`.  That is `a_func` function defines the interface and its
members.

Now the problem is, if rope wants to support implicit interfaces, how
should it find out these interfaces and their members.


Not Supporting Implicit Interfaces
----------------------------------

If we plan not to support implicit interfaces things simplify
considerably.  Function arguments objects are the common base class
of encountered arguments and function returned value object is the
common base class of returned values.


Supporting Implicit Interfaces
------------------------------

We need to find out the way these implicit interfaces are defined.
Actually each function defines an interface for each of its parameters
and the members of this interface are the objects that are passed as
that arguement.  Another thing to keep in mind is that implicit
interfaces are extended by inheritance relation, too.  For example::
  
  class C(A):
      
      def a_method(self):
          pass
  
  def a_func(arg):
      arg.a_method()
  
  another_func(C())

Renaming `arg.a_method` not only should rename `C.a_method` but also it
it should rename `A.a_method`.

We should be careful about situations like::
  
  def a_func(arg):
      if isinstance(arg, A):
          arg.do_something()
      else:
          arg.do_some_other_thing()


Implementation Issues
---------------------

To support implicit interfaces we need to make lots of changes.  First
of all we know that a function parameter can be anything, so using DOI
we have a set of objects for each parameter.  So the question that
comes up here is when do we need parameter objects.

* When refactoring and finding occurances
* When code assisting in a function

Also for a rename refactoring we need to check all functions and methods
for implicit interfaces that are involved.  This does not seem practical.
Find someway of making it possible.  Maybe we can find
all of the occurances of a method and for each check whether it is
invoked on a parameter or not.  Now that we have a bigger set of
methods we need to do the same for these methods.  When we're finished
we can perform the actual refactoring.  The challenge here is that we
should consider inheritance relations, too.


Which Is Right? Type Or Object Inference
========================================

Should we use type inference or object inference? I believe object
inference is better.  What we try do is to infer the object a variable
references during program execution.  Sometimes we are only interested
in the type of the referenced object and sometimes we need the object
itself.  This latter situation occurs when an instance holds
interesting information that does not exist in its type.

As an example classes(types) are instances of `type` class.  That is
their type is `type`.  But knowing their type does not give us much
information about the methods defined in these derived classes.


Getting Buried Under Layers
===========================

Starting from `rope.pycore` module, there are many layers that are
hidden beneath it.  Most of unit tests only test `PyCore` directly and
other parts are tested indirectly through many layers that lead to
`PyCore`.  I guess this is a bad sign.  Maybe I should put more time
in making each layer more testable and independant of other layers.


Builtin Types And Functions
===========================

What should we do about builtin functions and types?

Builtin types:

* list, typle
* dict
* str, unicode
* file
* set, frozenset
* int, float, long, complex
* iterator types
* boolean

Builtin constants:

* False
* True
* None
* NotImplemented
* Ellipsis

Builtin functions:

* range
* super

One approach to builtin types would be to use the `__builtin__` module
dynamically.  The other might be to write classes for the most
interesting ones like `list`\s, `dict`\s and `str`\s.


Refactoring `rope.codeanalyze` Module
=====================================

Merging `WordRangeFinder` and `StatementRangeFinder`.  Physical source
divisions:

* scope
* block
* logical line
* primary

After this refactoring, many places of rope can be refactored.  The
logical line is very useful in many places for instance.


What Rope Assumes...
====================

In order to simplify problems a bit, rope makes some assumptions about
the source code.  In futures some of this restrictions might be removed.

* All of the modules should use 4 spaces for indenting and no hard tabs.
* All files that end with ``.py`` are considered to be python files and
  all others not.
* Either all files should be under version control or none.
* All ``*.txt`` files are considered in reST formats.
* XXX


The GUI Mess; Working More on the UI Parts
==========================================

My ignorance to UI has make some modules like `rope.ui.core` and
`rope.ui.editor` very large and full of duplication.  These modules
need many refactorings.  Put more time on these modules.


Introducing Extension Points
----------------------------

Define Some extension points for the UI.  I think ``menu`` and ``key``
extension points are enough for now.  A difficulty for using extension
points is that extensions may be meaningful only in some contexts.
For example when no editor is open the ``Edit`` menu does not make any
sense or when not editing a python file the ``Run Module`` menu item
is meaningless.  Even in a context a menu item might be disabled
sometimes; like ``undo`` menu item.

Forgetting all these constraints we'd rather start with a simple hack.
The first thing to keep in mind is that after this refactoring we
probably want to put code assist dialogs in the same module maybe
`rope.ui.codeassist`.  After this refactoring `rope.ui.editor` will
contain only things that directly deal with editing and `rope.ui.core`
only contains features that directly deal with files and projects.  Or
maybe we can factor these things to a `rope.ui.filedialogs` module.

One of the main things to decide about is how to register these
callbacks to one of these extension points.  The easiest thing may be
to specify the modules that contain extensions.  `Core` class loads
those modules when needed.  We can either *push* or *pull* the data.
In the push method as a module is being loaded it registers its
components using methods that `Core` class makes available.
Alternatively in the pull model, the module can set some variables
that hold the data for registering the plugins.  When the modules
are loaded, `Core` reads those variables and registers those
components.

Another issue is how to pass `Core` or any needed context information
to these callbacks when they should execute; probably as arguments.


Shifting to `Action`\s
~~~~~~~~~~~~~~~~~~~~~~

After the addition of `rope.ui.extension` module followed by the
addition modules like `rope.ui.codeassist`, we have to gradually move
related dialogs to this modules.  This helps `Core` and `Editor`
modules not to be so much messy.


Better Dialogs
--------------

Many dialogs look very similar.  They can be factored.  Continue using
`rope.ui.uihelpers` module and extend it.


Not Resetting the Whole Editor
------------------------------

After actions like extract method, we reset the whole editor.  This is
slow and makes the undo difficult.  Find someway of solving this.  I
might be able to use `difflib` module.


Isolating Text Widget Features
------------------------------

Some of the features of GraphicalEditor can be used in other widgets.
Like completion, highlighting.


Defining the Responsibilities of `Core`
---------------------------------------

* Providing an interface to the plug-ins
* Providing methods for controlling rope?


Handling Multi-key Keyboard Shortcuts
-------------------------------------

Unfortunately `Tk` has problems for handling multi-key keyboard
shortcuts.  We can develop another independant keybinding system that
uses `Tk` to solve these problems.
